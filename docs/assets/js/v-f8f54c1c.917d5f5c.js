"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[5925],{87771:(a,s,n)=>{n.r(s),n.d(s,{data:()=>e});const e={key:"v-f8f54c1c",path:"/mybatis/06-mybatis-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BC%93%E5%AD%98.html",title:"延迟加载和缓存",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"延迟加载",slug:"延迟加载",children:[{level:3,title:"立即加载",slug:"立即加载",children:[]},{level:3,title:"激进式延迟加载",slug:"激进式延迟加载",children:[]},{level:3,title:"真-延迟加载",slug:"真-延迟加载",children:[]}]},{level:2,title:"Mybatis 缓存",slug:"mybatis-缓存",children:[{level:3,title:"Mybatis 一级缓存",slug:"mybatis-一级缓存",children:[]},{level:3,title:"Mybatis 二级缓存",slug:"mybatis-二级缓存",children:[]}]}],filePathRelative:"mybatis/06-mybatis-延迟加载和缓存.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},44927:(a,s,n)=>{n.r(s),n.d(s,{default:()=>t});const e=(0,n(66252).uE)('<h1 id="延迟加载和缓存" tabindex="-1"><a class="header-anchor" href="#延迟加载和缓存" aria-hidden="true">#</a> 延迟加载和缓存</h1><h2 id="延迟加载" tabindex="-1"><a class="header-anchor" href="#延迟加载" aria-hidden="true">#</a> 延迟加载</h2><p>如果一个对象关联另一个对象，那么在查询 A 对象的时候，会去关联查询 B 对象。</p><p>何时查询（加载）B 对象分为三种时机：</p><ul><li>立即加载</li><li>激进式延迟加载</li><li>延迟加载</li></ul><h3 id="立即加载" tabindex="-1"><a class="header-anchor" href="#立即加载" aria-hidden="true">#</a> 立即加载</h3><p>MyBaits 默认是立即加载，即在查询 A 对象的时候，会立即查询其关联的 B 对象。如果，B 对象也有关联对象，例如 C 对象，那么还会立即查询 C 对象，... 因此类推，直到把所有有关联关系的数据全部查询出来。</p><h3 id="激进式延迟加载" tabindex="-1"><a class="header-anchor" href="#激进式延迟加载" aria-hidden="true">#</a> 激进式延迟加载</h3><p>通过设置，可以启用延迟加载：</p><div class="language-xml ext-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>lazyLoadingEnabled<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>启用延迟加载之后，Mybatis 又是默认的激进地延迟加载。</p><p>Mybatis 内部会进行某种规则判断，从而使得激进式的延迟加载，有时候等同于立即加载，有时候等同于普通的延迟加载。</p><h3 id="真-延迟加载" tabindex="-1"><a class="header-anchor" href="#真-延迟加载" aria-hidden="true">#</a> 真-延迟加载</h3><p>可以再通过配置关闭掉激进地延迟加载，从而进入普通的延迟加载：</p><div class="language-xml ext-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>lazyLoadingEnabled<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>aggressiveLazyLoading<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>false<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>普通的延迟加载只会在你真正用到 A 对象的 B 属性时，再去查询/加载 B 对象。</p><h2 id="mybatis-缓存" tabindex="-1"><a class="header-anchor" href="#mybatis-缓存" aria-hidden="true">#</a> Mybatis 缓存</h2><h3 id="mybatis-一级缓存" tabindex="-1"><a class="header-anchor" href="#mybatis-一级缓存" aria-hidden="true">#</a> Mybatis 一级缓存</h3><h4 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h4><p>MyBatis 提供了查询缓存来缓存数据，从而达到提高查询新能的要求。MyBatis 的缓存分为一级缓存和二级缓存。</p><p>MyBatis 的一级缓存是 SqlSession 级别的缓存（<small>在操作数据库时需要构造 SqlSession 对象</small>），每个 SqlSession 对象中都有一个 HashMap 对象用于缓存数据，不同的 SqlSession 之间缓存的数据互不影响。</p><blockquote><p>提前说明一下，当 mybatis 与 spring 整合后，<strong>如果没有事务，一级缓存是失效的！</strong></p><p>原因就是两者结合后，sqlsession 如果发现当前没有事务，那么每执行一个 mapper 方法之后，sqlsession 就被关闭了<small>（ <em><code>session.close()</code></em> ）</small>。</p><p>所以记得给 Service 的方法的脑袋上面加 <em><strong>@Transactional</strong></em> 。</p></blockquote><p>在参数和 SQL 完全相同的情况下，使用同一个 SqlSession 对象调用同一个 Mapper 方法，往往只执行一次 SQL 语句。因为如果没有声明需要刷新缓存并且缓存没有超时，SqlSession 都只会取出当前缓存的数据<small>，而不是执行 SQL 语句</small>。</p><p>如果 SqlSession 执行了 DML 操作，并提交数据库，Mybatis 会清空 SqlSession 中的一级缓存，这样做的目的是保证缓存中存储的数据是最新的，避免出现脏读现象。</p><h4 id="刷新缓存的时机" tabindex="-1"><a class="header-anchor" href="#刷新缓存的时机" aria-hidden="true">#</a> 刷新缓存的时机</h4><ul><li><p>如果 SqlSession 调用了 <em><strong>close</strong></em> 方法，则一级缓存不可用/销毁。</p></li><li><p>如果 SqlSession 调用了 <em><strong>clearCache</strong></em> 方法，则一级缓存中缓存的数据被清空。</p></li><li><p>如果 SqlSession 执行了一个 DML 操作，则一级缓存中缓存的数据被清空。</p></li></ul><h3 id="mybatis-二级缓存" tabindex="-1"><a class="header-anchor" href="#mybatis-二级缓存" aria-hidden="true">#</a> Mybatis 二级缓存</h3><p>二级缓存是 Mapper 级别<small>（也叫 namespace 级别）</small>的缓存，同样使用 HashMap 进行数据存储。</p><ul><li><p>二级缓存是以 namespace 为单位的，不同的 namespace 下的操作相互隔离。</p></li><li><p>增删改操作会清空 namespace 下的全部缓存。</p></li></ul><p>如果开启了二级缓存，那么在关闭 sqlsession 后，会把该 sqlsession 一级缓存中的数据添加到 namespace 的二级缓存中。</p><p>二级缓存比一级缓存作用域更大，多个 sqlsession 可以共用二级缓存，即，二级缓存是跨 sqlsession 的。</p><blockquote><p><small>例如，关闭一个 sqlsession 之后，打开一个新的 sqlsession，执行同一条 sql 语句，会利用上一次的缓存数据。</small></p></blockquote><p>mybatis <strong>默认没有开启二级缓存</strong> ，需要在配置中进行配置才能使用。打开二级缓存分为三步：</p><ol><li><p>打开二级缓存总开关</p></li><li><p>打开需要使用二级缓存的 mapper 的开关。</p></li><li><p>POJO 序列化</p></li></ol><h4 id="打开二级缓存总开关" tabindex="-1"><a class="header-anchor" href="#打开二级缓存总开关" aria-hidden="true">#</a> 打开二级缓存总开关</h4><p>打开总开关，只需要在 mybatis 总配置文件中加入一行设置</p><div class="language-xml ext-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>\n  <span class="token comment">&lt;!--开启二级缓存--&gt;</span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>cacheEnabled<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>true<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="打开需要使用二级缓存的-mapper-的开关。" tabindex="-1"><a class="header-anchor" href="#打开需要使用二级缓存的-mapper-的开关。" aria-hidden="true">#</a> 打开需要使用二级缓存的 mapper 的开关。</h4><p>在需要开启二级缓存的 <em><strong>mapper.xml</strong></em> 中加入 caceh 标签</p><div class="language-xml ext-xml line-numbers-mode"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span> <span class="token punctuation">/&gt;</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h4 id="pojo-序列化" tabindex="-1"><a class="header-anchor" href="#pojo-序列化" aria-hidden="true">#</a> POJO 序列化</h4><p>让需要使用二级缓存的 POJO 类实现 Serializable 接口，如</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Department</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>通过之前三步操作就可以使用二级缓存了。</p>',44),t={render:function(a,s){return e}}}}]);