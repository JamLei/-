"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[9879],{95072:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a={key:"v-12f12be4",path:"/spring-boot/99-spring-boot-webflux.html",title:"Spring WebFlux",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"响应式编程模型",slug:"响应式编程模型",children:[]},{level:2,title:"以 Spring MVC 的方式使用 Spring WebFlux",slug:"以-spring-mvc-的方式使用-spring-webflux",children:[]},{level:2,title:"另一种使用 WebFlux 的方式",slug:"另一种使用-webflux-的方式",children:[]},{level:2,title:"Spring 中的响应式编程",slug:"spring-中的响应式编程",children:[{level:3,title:"HttpHandler",slug:"httphandler",children:[]}]}],filePathRelative:"spring-boot/99-spring-boot-webflux.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},34808:(e,n,s)=>{s.r(n),s.d(n,{default:()=>p});const a=(0,s(66252).uE)('<h1 id="spring-webflux" tabindex="-1"><a class="header-anchor" href="#spring-webflux" aria-hidden="true">#</a> Spring WebFlux</h1><p>随着响应式编程的流行，Spring 5 增加了响应式编程技术栈：Spring WebFlux 。Spring WebFlux 是完全无阻塞的，可以支持 Reactive Streams 被压，并且可以在诸如 Netty、Undertow 和 Servlet 3.1+ 容器的服务器上运行。</p><blockquote><p>Spring WebFlux 与 Spring MVC 这两个 Web 框架分别位于 spring-webflux 和 spring-webmvc 模块中两者处于同等的地位，且相互间是独立的，不存在相互依赖关系。</p></blockquote><p><img src="https://hemiao3000.gitee.io/java-note-img/images/spring-boot/img/spring-webflux-01.png" alt="spring-webflux-01.png"></p><p>Reactor 是 Spring WebFlux 所基于的响应式库。Reactor 是一个 Reactive Streams 库，它提供了 Mono 和 Flux API 类型，通过一组丰富的操作符来处理 0...1 和 0...N 的数据序列。</p><blockquote><p>作为一般规则，WebFlux API 接受一个普通的 Publisher 作为输入，在内部将它调整为 Reactor 类型，使用它们，然后返回 Flux 或 Mono 作为输出。</p></blockquote><h2 id="响应式编程模型" tabindex="-1"><a class="header-anchor" href="#响应式编程模型" aria-hidden="true">#</a> 响应式编程模型</h2><p>spring-web 模块包含了 spring-webflux 所需要的基础组件，这些基础组件包含 HTTP 抽象、受支持服务器的 Reactive Streams 适配器、编码器和解码器，以及可与 Servlet API 相媲美但遵循非阻塞协议的核心 WebHandler API 等。</p><p>在此基础上，Spring WebFlux 提供了两种编程模型的选择：</p><ul><li><p>带注解的控制器</p><p>与 Spring MVC 所使用的注解一样，都是基于 spring-web 模块中的相同的注解。</p></li><li><p>函数式端点</p><p>基于 lambda 的轻量级函数式编程模型。它与注解控制器的最大区别在于，应用程序负责从头到尾的请求处理，通过注解声明意图并被回调。</p></li></ul><p><img src="https://hemiao3000.gitee.io/java-note-img/images/spring-boot/img/spring-webflux-02.png" alt="spring-webflux-02.png"></p><h2 id="以-spring-mvc-的方式使用-spring-webflux" tabindex="-1"><a class="header-anchor" href="#以-spring-mvc-的方式使用-spring-webflux" aria-hidden="true">#</a> 以 Spring MVC 的方式使用 Spring WebFlux</h2><p>WebFlux 可以以你『熟悉』的方式<small>（基于注解）</small>使用，<small>让你根本意识不到你所使用的是 spring-webmvc 还是 spring-webflux</small>。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WorldController</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/world&quot;</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> <span class="token class-name">UserVO</span> <span class="token function">world</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">UserVO</span> vo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserVO</span><span class="token punctuation">(</span><span class="token string">&quot;tom&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> <span class="token class-name">Mono</span><span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span>vo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这里和『普通』的 @RequestMapping 的区别就在于它的返回值必须是 <strong>Mono</strong> 或者是 <strong>Flux</strong> 。</p><blockquote><p>另外，有些文档说需要使用 @EnableWebFlux 注解启用 WebFlux，但是经测试，不加也可以。</p></blockquote><p>如果你想『看到熟悉』的页面跳转功能，WebFlux 也是可以的（见最后）。</p><p>总之，因为 spring-web 模块的抽象，你使用 spring-webmvc 还是使用 spring-webflux 其实写出来的代码可以一样。</p><h2 id="另一种使用-webflux-的方式" tabindex="-1"><a class="header-anchor" href="#另一种使用-webflux-的方式" aria-hidden="true">#</a> 另一种使用 WebFlux 的方式</h2><p>Spring WebFlux 包含了一个轻量级的函数式编程模型，其中函数用于路由和请求处理<small>（并且相关接口 API 都是基于不可变性而设计的）</small>。它是上述的基于注解的编程模型的另一种替代方案。</p><ul><li><p>HandlerFunction</p><p>ServerRequest 和 ServerResponse 是不可变接口，<small>它们提供了 JDK 8 对 HTTP 带 Reactive Streams 背压的请求和响应的友好访问。</small>请求主题由 Reactor 的 Flux 或 Mono 表示。</p><ul><li><p>ServerRequest 提供了对于 HTTP Method、URI、Http Header 及请求参数等的访问。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> str <span class="token operator">=</span> request<span class="token punctuation">.</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul></li><li><p>RouterFunction</p></li></ul><h2 id="spring-中的响应式编程" tabindex="-1"><a class="header-anchor" href="#spring-中的响应式编程" aria-hidden="true">#</a> Spring 中的响应式编程</h2><p>spring-web 模块提供底层基础设施和 HTTP 抽象<small>（客户端和服务器）</small>，以构建响应式 Web 应用程序。所有的公共 API 都是围绕 Reactive Streams<small>（以 Reactor 作为核心）</small>来实现的。</p><h3 id="httphandler" tabindex="-1"><a class="header-anchor" href="#httphandler" aria-hidden="true">#</a> HttpHandler</h3><p>每个 HTTP 服务器都有一些用于 HTTP 请求处理的 API 。HttpHandler 是一种处理请求和响应的简单契约。</p><p>spring-web 模块包含适用于每个受支持服务器的适配器：</p><hr><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><hr><p>Spring-Webflux与Thymeleaf整合（Could not resolve view with name &#39;xxxx&#39;）</p><p>在 ServerResponseResultHandler做结果处理时会使用ViewResolverRegistry中注册的视图解析器，但是这个地方debug发现视图解析器是0个。</p><p>https://blog.csdn.net/fly_leopard/article/details/88355349</p><p>@Configuration //@EnableWebFlux public class WebFluxConfig implements WebFluxConfigurer {</p><pre><code>@Autowired  // 引入spring-boot-starter-thymeleaf自动会注入该bean\nprivate ThymeleafReactiveViewResolver thymeleafReactiveViewResolver;\n\n/**\n * 加入thymeleaf试图解析器，不然找不到view name\n */\n@Override\npublic void configureViewResolvers(ViewResolverRegistry registry) {\n    registry.viewResolver(thymeleafReactiveViewResolver);\n}\n</code></pre><p>}</p>',35),p={render:function(e,n){return a}}}}]);