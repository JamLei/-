"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[9455],{91894:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-2dbfe8f9",path:"/java/99-Java%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98.html",title:"Java 时区问题",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"Java 时区相关",slug:"java-时区相关",children:[{level:3,title:"时间格式",slug:"时间格式",children:[]},{level:3,title:"表示时间相关的类",slug:"表示时间相关的类",children:[]}]},{level:2,title:"时区转换",slug:"时区转换",children:[]},{level:2,title:"不同地区的服务器统一时间的解决方案",slug:"不同地区的服务器统一时间的解决方案",children:[]}],filePathRelative:"java/99-Java时区问题.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},35020:(n,a,s)=>{s.r(a),s.d(a,{default:()=>t});const e=(0,s(66252).uE)('<h1 id="java-时区问题" tabindex="-1"><a class="header-anchor" href="#java-时区问题" aria-hidden="true">#</a> Java 时区问题</h1><h2 id="java-时区相关" tabindex="-1"><a class="header-anchor" href="#java-时区相关" aria-hidden="true">#</a> Java 时区相关</h2><h3 id="时间格式" tabindex="-1"><a class="header-anchor" href="#时间格式" aria-hidden="true">#</a> 时间格式</h3><p>UTC 是以原子时计时，更加精准，适应现代社会的精确计时。不过一般使用不需要精确到秒时，视为等同。GMT 是前世界标准时，UTC 是现世界标准时。</p><pre><code>每年格林尼治天文台会发调时信息，基于 UTC 。\n</code></pre><p>GMT 和 UTC 可以视为几乎是等同的，UTC 更精准，有闰秒的概念。</p><ul><li><p>世界标准时间 UTC：<code>2010-10-12T15:24:22Z</code> or <code>2010-10-12 15:24:22Z</code></p><p>其中 <strong>T</strong> 表示时分秒的开始<small>（或者日期与时间的间隔）</small>，<strong>Z</strong> 表示这是一个世界标准时间</p></li><li><p>本地时间<small>（也叫不含时区信息的时间）</small>：<code>2010-10-12T15:24:22</code></p><p>本地时间的末尾没有 <strong>Z</strong>。对于不同时区的人而言，如果两者交流间使用的是本地时间，那么会引发歧义。</p></li><li><p>含有时区的时间：<code>2017-12-13T09:47:07.153+08:00[Asia/Shanghai]&quot;</code></p><p><code>+08:00</code> 表示该时间是由世界标准时间加了 8 个小时得到的，<code>[Asia/Shanghai]</code> 表示时区。</p><p>由于 <code>+08:00</code> 的存在，所以将表示时区的 <code>[Asia/Shanghai]</code> 省略掉，也不会导致时间概念上的歧义。</p></li></ul><h3 id="表示时间相关的类" tabindex="-1"><a class="header-anchor" href="#表示时间相关的类" aria-hidden="true">#</a> 表示时间相关的类</h3><p>在 Java 编码中，表示时间的类主要有个：String、Instant、LocalDateTime、ZonedDateTime 。</p><p><strong>String</strong> 是字符串形式的时间，<strong>Instant</strong> 是时间戳，<strong>LocalDateTime</strong> 是不含时区信息的时间，<strong>ZonedDateTime</strong> 是含有时区信息的时间。</p><ul><li><p>LocalDateTime</p><p>符合格式的 String 可以直接转换为 LocalDateTime 。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token class-name">LocalDateTime</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>\n    <span class="token string">&quot;2019-12-15 10:10:10&quot;</span><span class="token punctuation">,</span> \n    <span class="token class-name">DateTimeFormatter</span><span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>LocalDateTime 字面意思是本地时间，实际上它可以理解为不含时区信息的时间，只储存了年月日时分秒，要表达是哪里的时间需要时区解释，即，这是一个逻辑上有歧义的时间。</p></li><li><p>Instant 与 ZonedDateTime</p><p>Instant 是时间戳，是指世界标准时格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒<small>（即北京时间 1970 年 01 月 01 日 08 时 00 分 00 秒）</small>起至现在的总秒数。</p><p>注意，由此可见 Instant 本身已经携带了时区信息，也就是 0 时区。<small>当然，这只是默认值，有需要的话你可以指定的。</small></p><p>ZonedDateTime 是含有时区信息的时间，可以理解为它是 Instant 的格式化对象。</p><p>JDK 8 以前的时区是用 TimeZone，TimeZone ID 是在 java 里 ZoneInfoFile 类加载的。在 jvm 初始化的时候，会读取 jdk 安装目录下的 <code>${java.home}/jre/lib/tzdb.dat</code>，放到其成员变量为 zones 的 ConcurrentHashMap 里。当调用 TimeZone.getTimeZone(id) 方法时，会用 id 到这个 map 里进行匹配获取到指定 id 的时区。其中<code>TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;)</code> 和 <code>TimeZone.getTimeZone(&quot;GMT+8&quot;)</code> 是相同的，可以相互替换使用。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ZonedDateTime</span><span class="token punctuation">.</span><span class="token function">ofInstant</span><span class="token punctuation">(</span><span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ZoneId</span><span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ZonedDateTime</span><span class="token punctuation">.</span><span class="token function">ofInstant</span><span class="token punctuation">(</span><span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;Australia/Darwin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>相同的 Instant，在不同的时区有不同的展示时间，所以在用 Instant 构造 ZonedDateTime 的时候需要传入时区；ZonedDateTime 可以直接转化为 Instant ，并且不同的 ZonedDateTime 可能会生成同样的 Instant 。</p></li></ul><h2 id="时区转换" tabindex="-1"><a class="header-anchor" href="#时区转换" aria-hidden="true">#</a> 时区转换</h2><p>用户输入的 String 类型的时间是没有时区信息的，需要人为指定时区再解析。</p><p>解析的步骤分 2 步： 先确定用户时区</p><ol><li><p>把用户输入的时间转化为世界标准时间；Instant.parse(&quot;2010-10-12T15:24:22Z&quot;)</p></li><li><p>再把世界标准时间转为需要的时区的时间。ZonedDateTime.ofInstant(instant,ZoneId.systemDefault());</p></li></ol><h2 id="不同地区的服务器统一时间的解决方案" tabindex="-1"><a class="header-anchor" href="#不同地区的服务器统一时间的解决方案" aria-hidden="true">#</a> 不同地区的服务器统一时间的解决方案</h2><p>首先后端封装一个接口后获取服务器相对 GMT（格林尼治标准时间）时间的偏移量：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">TimeZone</span> zone <span class="token operator">=</span> <span class="token class-name">TimeZone</span><span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zone<span class="token punctuation">.</span><span class="token function">getRawOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这段代码放在不同时区的服务器上执行结果会不同<small>（前提是服务器的时区设置跟本地时区一致）</small>。如果在泰国执行结果为 25200000ms ，换算成小时为 7 ，说明泰国的时区的偏移量相对于 GMT 标准时间相差 7 小时。下文简称“时区偏移量”。</p><p>前端首先调用该接口获取服务器的时区偏移量，再在浏览器上获取本地的时区偏移量，计算出两个偏移量的差值。本地浏览器上获取当前的时间戳，减去上一步计算出来的差值即可得到服务器这个时间的时间戳，把这个时间戳传给后端 再转换成时间，就是服务器对应的时间，存入数据库即可。</p><p>前端：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 服务的时区偏移量，通过接口获得，注意换成负值</span>\n<span class="token keyword">var</span> serveroffset<span class="token operator">=</span><span class="token operator">-</span><span class="token number">25200000</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 获取本地浏览器的时区偏移量</span>\n<span class="token keyword">var</span> localOffset <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">getTimezoneOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">60000</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 得到本地和偏移量的差值</span>\n<span class="token keyword">var</span> deffoffset<span class="token operator">=</span>localOffset<span class="token operator">-</span><span class="token punctuation">(</span>serveroffset<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 获取本地浏览器时间戳</span>\n<span class="token keyword">var</span> localTime <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 计算出传到服务器的时间戳</span>\n<span class="token keyword">var</span> servertime<span class="token operator">=</span>localTime<span class="token operator">+</span>deffoffset<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>通过上述方式，可以实现服务器全球各地部署，系统都可以正常使用。</p>',23),t={render:function(n,a){return e}}}}]);