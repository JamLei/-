"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[830],{49007:(t,n,e)=>{e.r(n),e.d(n,{data:()=>s});const s={key:"v-01635dd7",path:"/utility/guava/07-Preconditions.html",title:"校验工具",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"utility/guava/07-Preconditions.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},61722:(t,n,e)=>{e.r(n),e.d(n,{default:()=>a});const s=(0,e(66252).uE)('<h1 id="校验工具" tabindex="-1"><a class="header-anchor" href="#校验工具" aria-hidden="true">#</a> 校验工具</h1><p>Guava 提供 <strong>Preconditions</strong> 类，用于帮助逻辑上的前置校验工作。这些方法都是静态方法。</p><p>每个方法都有 3 个变种：</p><ul><li><p>没有额外参数：抛出的异常中没有错误消息；</p></li><li><p>有一个 Object 对象作为额外参数：抛出的异常使用 <strong>Object.toString()</strong> 作为错误消息；可用于抛出自定义的异常对象。</p></li><li><p>有一个 String 对象作为额外参数，并且有一组任意数量的附加 Object 对象：这个变种处理异常消息的方式有点类似 printf，不过只支持 <strong>%s</strong> 指示符。例如：</p></li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token function">checkArgument</span><span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;Argument was %s but expected nonnegative&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">checkArgument</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">,</span> <span class="token string">&quot;Expected i &lt; j, but %s &gt; %s&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><table><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">条件不满足时抛出的异常</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>checkArgument</strong></td><td style="text-align:left;">IllegalArgumentException</td></tr><tr><td style="text-align:left;"><strong>checkNotNull</strong></td><td style="text-align:left;">NullPointerException</td></tr><tr><td style="text-align:left;"><strong>checkState</strong></td><td style="text-align:left;">IllegalStateException</td></tr><tr><td style="text-align:left;"><strong>checkElementIndex</strong></td><td style="text-align:left;">IndexOutOfBoundsException</td></tr><tr><td style="text-align:left;"><strong>checkPositionIndex</strong></td><td style="text-align:left;">IndexOutOfBoundsException</td></tr><tr><td style="text-align:left;"><strong>checkPositionIndexes</strong></td><td style="text-align:left;">IndexOutOfBoundsException</td></tr></tbody></table><p>注意 <strong>Index</strong> 和 <strong>Position</strong> 的区别：</p><ul><li><p>索引<small>（index）</small>通常适用于定位字符串或容器中的某个元素，所以，其合法范围范围 0 ... n-1</p></li><li><p>位置值<small>（Position）</small>通常用于截取字符串或容器，在截取时由于区间是左开右闭 [a, b)，所以 b == n 时，b 也是合法的。</p></li><li><p>简单来说，Position 的上限比 Index 的上限多一个。</p></li></ul><p>使用 Predication 的理由：</p><ul><li><p>在静态导入后，Guava 方法非常清楚明晰。checkNotNull 清楚地描述做了什么，会抛出什么异常；</p></li><li><p>checkNotNull 直接返回检查的参数，让你可以在构造函数中保持字段的单行赋值风格：<code>this.field = checkNotNull(field)</code></p></li><li><p>简单的、参数可变的 printf 风格异常信息。鉴于这个优点，在 JDK7 已经引入 <code>Objects.requireNonNull</code> 的情况下，我们仍然建议你使用 checkNotNull 。</p></li></ul><p>在编码时，如果某个值有多重的前置条件，我们建议你把它们放到不同的行，这样有助于在调试时定位。此外，把每个前置条件放到不同的行，也可以帮助你编写清晰和有用的错误消息。</p>',11),a={render:function(t,n){return s}}}}]);