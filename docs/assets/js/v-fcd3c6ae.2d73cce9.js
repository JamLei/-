"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[4215],{80306:(t,e,n)=>{n.r(e),n.d(e,{data:()=>a});const a={key:"v-fcd3c6ae",path:"/jdbc/04-JDBC%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1.html",title:"事务",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"事务的 ACID 属性",slug:"事务的-acid-属性",children:[]},{level:2,title:"三大问题",slug:"三大问题",children:[{level:3,title:"脏读问题",slug:"脏读问题",children:[]},{level:3,title:"不可重复读问题",slug:"不可重复读问题",children:[]},{level:3,title:"幻读问题",slug:"幻读问题",children:[]}]},{level:2,title:"四个隔离级别",slug:"四个隔离级别",children:[]},{level:2,title:"JDBC 事务的自动提交和隔离级别",slug:"jdbc-事务的自动提交和隔离级别",children:[]}],filePathRelative:"jdbc/04-JDBC中的事务.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},65534:(t,e,n)=>{n.r(e),n.d(e,{default:()=>l});const a=(0,n(66252).uE)('<h1 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h1><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>『<strong>事务</strong>』本身是数据库领域中的概念，而非编程语言<small>（如 Java）</small>中的概念！是因为我们要在代码中去操作数据库，因此，我们的代码中『才会涉及』、『才有了事务』的概念。不要搞错了因果关系！</p></div><h2 id="事务的-acid-属性" tabindex="-1"><a class="header-anchor" href="#事务的-acid-属性" aria-hidden="true">#</a> 事务的 ACID 属性</h2><p>数据库事务的正确执行的 4 个基本要素是 原子性<small>（<strong>A</strong>tommicity）</small>、一致性<small>（<strong>C</strong>onsistency）</small>、隔离性<small>（<strong>I</strong>solation）</small>和 持久性<small>（<strong>D</strong>urability）</small>。</p><table><thead><tr><th style="text-align:left;">问题</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">原子性            </td><td style="text-align:left;">整个事务中的操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节，仅完成一部分。</td></tr><tr><td style="text-align:left;">一致性</td><td style="text-align:left;">事务必须使数据库从一个一致状态变为另一个一致状态。</td></tr><tr><td style="text-align:left;">隔离性</td><td style="text-align:left;">事务的隔离性是指一个事务的执行过程中不被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的事务之间不能互相干扰。</td></tr><tr><td style="text-align:left;">持久性</td><td style="text-align:left;">在事务完成以后，该事务对数据库所做的更改便持久保存在数据库中，并不会被回滚。</td></tr></tbody></table><h2 id="三大问题" tabindex="-1"><a class="header-anchor" href="#三大问题" aria-hidden="true">#</a> 三大问题</h2><p>三大问题从 严重 到 轻度 以此如下：</p><h3 id="脏读问题" tabindex="-1"><a class="header-anchor" href="#脏读问题" aria-hidden="true">#</a> 脏读问题</h3><p>对于两个事务 T1 和 T2 可能会出现如下情况，T1 读取了已经被 T2 <strong>更新但是还未提交</strong> 的字段，若此时 T2 回滚，那么 T1 读取到的内容就是临时且无效的。</p><table><thead><tr><th style="text-align:center;">时刻</th><th style="text-align:center;">事务一（老公）</th><th style="text-align:center;">事务二（老婆）</th></tr></thead><tbody><tr><td style="text-align:center;">T1</td><td style="text-align:center;">查询余额，显示 10k</td><td style="text-align:center;">——</td></tr><tr><td style="text-align:center;">T2</td><td style="text-align:center;">——</td><td style="text-align:center;">查询余额，显示 10k</td></tr><tr><td style="text-align:center;">T3</td><td style="text-align:center;">——</td><td style="text-align:center;">网购 1千，显示 9k</td></tr><tr><td style="text-align:center;">T4</td><td style="text-align:center;">请客吃饭开销 1k，显示余额 8k</td><td style="text-align:center;">——</td></tr><tr><td style="text-align:center;">T5</td><td style="text-align:center;">提交事务</td><td style="text-align:center;">——</td></tr><tr><td style="text-align:center;">T6</td><td style="text-align:center;">——</td><td style="text-align:center;">回滚事务</td></tr><tr><td style="text-align:center;">T7</td><td style="text-align:center;">——</td><td style="text-align:center;">最终余额 8k</td></tr></tbody></table><p>所谓脏读，指的就是读到了“脏”数据，即一个事务读取到了另一个事务未提交的数据。</p><h3 id="不可重复读问题" tabindex="-1"><a class="header-anchor" href="#不可重复读问题" aria-hidden="true">#</a> 不可重复读问题</h3><p>对于两个事务 T1 和 T2 可能会出现如下情况，T1 读取了一个字段，然后 T2 更新了这个字段。之后，T1 再次读取该字段时，会发现值发生了变化。</p><table><thead><tr><th style="text-align:center;">时刻</th><th style="text-align:center;">事务一（老公）</th><th style="text-align:center;">事务二（老婆）</th></tr></thead><tbody><tr><td style="text-align:center;">T1</td><td style="text-align:center;">查询余额，显示10k</td><td style="text-align:center;">——</td></tr><tr><td style="text-align:center;">T2</td><td style="text-align:center;">——</td><td style="text-align:center;">查询余额，显示 10k</td></tr><tr><td style="text-align:center;">T3</td><td style="text-align:center;">——</td><td style="text-align:center;">网购，开销 1k，余额 9k</td></tr><tr><td style="text-align:center;">T4</td><td style="text-align:center;">请客吃饭，预计开销 2k</td><td style="text-align:center;">——</td></tr><tr><td style="text-align:center;">T5</td><td style="text-align:center;">——</td><td style="text-align:center;">网购，开销 8k，余额 1k</td></tr><tr><td style="text-align:center;">T6</td><td style="text-align:center;">——</td><td style="text-align:center;">提交事务</td></tr><tr><td style="text-align:center;">T7</td><td style="text-align:center;">吃完买单，显示余额 1k，不够付账。</td><td style="text-align:center;">——</td></tr></tbody></table><p>不可重复读，指的是理论上的同一条数据，重复读取，居然会不一样，不具备可重复性。</p><h3 id="幻读问题" tabindex="-1"><a class="header-anchor" href="#幻读问题" aria-hidden="true">#</a> 幻读问题</h3><p>对于两个事务 T1 和 T2 可能会出现如下情况，T1 从一个表中读取了一个字段，然后 T2 在该表中插入了一些新的数据。之后，T1 再次读取该字段时，会发现多出来几行。</p><table><thead><tr><th style="text-align:center;">时刻</th><th style="text-align:center;">事务一（老公）</th><th style="text-align:center;">事务二（老婆）</th></tr></thead><tbody><tr><td style="text-align:center;">T1</td><td style="text-align:center;">——</td><td style="text-align:center;">查询信用卡消费记录，显示 10 条记录</td></tr><tr><td style="text-align:center;">T2</td><td style="text-align:center;">网购</td><td style="text-align:center;">——</td></tr><tr><td style="text-align:center;">T3</td><td style="text-align:center;">提交事务</td><td style="text-align:center;">——</td></tr><tr><td style="text-align:center;">T4</td><td style="text-align:center;">——</td><td style="text-align:center;">打印消费记录，有11条记录</td></tr></tbody></table><p>幻读，和不可重复读类似，第二次读取的数据相较于第一次居然发生了变化，仿佛看到了幻觉。</p><p>『不可重复读』和『幻读』有一定的相似性，都是指<small>（在本人未改变的情况下）</small>第二次读取的数据，与第一次读取结果不一样。不过它们描述的侧重点（及造成的影响程度）不一样。</p><ul><li>不可重复读问题，强调的是某一条数据的内容在“我”两次读取间，发生了改变。<small>（因为 update 语句）</small></li><li>幻读问题，强调的整个数据的数据总量，在“我”两次读取间，发生了改变。<small>（因为 insert / delete 语句）</small></li><li>幻读问题 造成的危害要小于不可重复读问题。</li></ul><p><strong>不可重复读</strong> 和 <strong>幻读</strong> 在一定程度上是可接受的，而 <strong>脏读</strong> 是完全不可接受的。</p><h2 id="四个隔离级别" tabindex="-1"><a class="header-anchor" href="#四个隔离级别" aria-hidden="true">#</a> 四个隔离级别</h2><p>隔离级别表示：<strong>当『我』操作这张表时，『其他人』对这张表还有多大的操作权限</strong> 。『我』的隔离级别越高，其他人的权利就越小，那么『他』要执行他想要执行的操作而没有权限时，那就只能 <strong>等</strong>『我』操作完 。</p><p>数据库领域有四个隔离级别<small>（注意，这并非 Java 中特有的概念）</small>，针对于上述三大问题，四个隔离级别，从 <em>解决不了任何问题</em> 到 <em>解决所有问题</em> ，每一级多解决一个问题。</p><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:left;">解决问题</th><th style="text-align:left;">备注</th></tr></thead><tbody><tr><td style="text-align:center;">READ_UNCOMMITTED</td><td style="text-align:left;">解决不了任何问题</td><td style="text-align:left;">——</td></tr><tr><td style="text-align:center;">READ_COMMITTED</td><td style="text-align:left;">可以解决<code>脏读</code>问题</td><td style="text-align:left;">——</td></tr><tr><td style="text-align:center;">REPEATABLE_READ</td><td style="text-align:left;">可以解决<code>不可重复读</code>问题</td><td style="text-align:left;"><small>包括解决<code>脏读</code>问题</small></td></tr><tr><td style="text-align:center;">SERIALIZABLE</td><td style="text-align:left;">解决<code>幻读</code>问题</td><td style="text-align:left;"><small>包括解决<code>不可重复读</code>和<code>脏读</code>问题</small></td></tr></tbody></table><p>隔离级别越高，事务间的相互干扰就越小，数据的一致性就越好，但同时并发性就越弱。</p><p>MySQL 支持四种隔离级别，默认事务隔离级别为 <strong>Repeatable Read</strong> 。</p><h2 id="jdbc-事务的自动提交和隔离级别" tabindex="-1"><a class="header-anchor" href="#jdbc-事务的自动提交和隔离级别" aria-hidden="true">#</a> JDBC 事务的自动提交和隔离级别</h2><p>Connection 类中有如下实例方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 设置事务开启自动提交</span>\n<span class="token keyword">void</span> <span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> autoCommit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 设置事务的隔离级别</span>\n<span class="token keyword">void</span> <span class="token function">setTransactionIsolation</span><span class="token punctuation">(</span><span class="token keyword">int</span> level<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span>\n<span class="token class-name">Connection</span><span class="token punctuation">.</span>TRANSACTION_NONE\n<span class="token class-name">Connection</span><span class="token punctuation">.</span>TRANSACTION_READ_UNCOMMITTED\n<span class="token class-name">Connection</span><span class="token punctuation">.</span>TRANSACTION_READ_COMMITTED\n<span class="token class-name">Connection</span><span class="token punctuation">.</span>TRANSACTION_REPEATABLE_READ\n<span class="token class-name">Connection</span><span class="token punctuation">.</span>TRANSACTION_SERIALIZABLE\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div>',31),l={render:function(t,e){return a}}}}]);