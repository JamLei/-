"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[7906],{56102:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a={key:"v-84c4ee86",path:"/docker/99-%E5%85%B6%E4%BB%96.html",title:"其它",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"Docker容器启动时初始化Mysql数据库",slug:"docker容器启动时初始化mysql数据库",children:[{level:3,title:"前言",slug:"前言",children:[]},{level:3,title:"原理",slug:"原理",children:[]},{level:3,title:"自定义Dockerfile",slug:"自定义dockerfile",children:[]}]},{level:2,title:"docker 的宿主系统是 centos，为什么可以运行 ubuntu 的镜像呢？",slug:"docker-的宿主系统是-centos-为什么可以运行-ubuntu-的镜像呢",children:[]}],filePathRelative:"docker/99-其他.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},61616:(e,n,s)=>{s.r(n),s.d(n,{default:()=>u});var a=s(66252);const l=(0,a.uE)('<h1 id="其它" tabindex="-1"><a class="header-anchor" href="#其它" aria-hidden="true">#</a> 其它</h1><h2 id="docker容器启动时初始化mysql数据库" tabindex="-1"><a class="header-anchor" href="#docker容器启动时初始化mysql数据库" aria-hidden="true">#</a> Docker容器启动时初始化Mysql数据库</h2><h3 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h3><p>Docker在开发中使用的越来越多了，最近搞了一个Spring Boot应用，为了方便部署将Mysql也放在Docker中运行。那么怎么初始化 SQL脚本以及数据呢？</p>',4),r=(0,a.Uk)("我这里有两个传统方案。 第一种方案是在容器启动后手动导入，太low了不行。第二种在Spring Boot客户端连接Mysql容器时初始化数据库，你可以参考"),i={href:"https://www.felord.cn/spring-boot-flyway.html",target:"_blank",rel:"noopener noreferrer"},t=(0,a.Uk)("《使用flyway进行数据库版本控制》"),c=(0,a.Uk)("一文，但是这依赖客户端的能力。能不能做到Mysql容器启动时就自己初始化数据库呢？当然可以！今天就来演示一下。全部代码见文末。"),d=(0,a.uE)('<h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h3><p>当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库。这些文件会按照字母的顺序执行。默认情况下它们会初始化在启动容器时声明的 MYSQL_DATABASE变量定义的数据库中,例如下面的命令会初始化一个REGION_DB 数据库：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ docker run --name some-mysql -e <span class="token assign-left variable">MYSQL_DATABASE</span><span class="token operator">=</span>REGION_DB -d mysql:tag\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>如果你的启动命令没有指定数据库那么就必须在数据库DDL脚本中声明并指定使用该数据库。否则就会实现下面的异常：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>ERROR 1046 (3D000) at line 7: No database selected\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>那么接下来我们将利用这一机制来实现Docker容器启动时初始化数据库。</p><h3 id="自定义dockerfile" tabindex="-1"><a class="header-anchor" href="#自定义dockerfile" aria-hidden="true">#</a> 自定义Dockerfile</h3><p>我们编写自己的Dockerfile来实现我们的需求，这里以 Mysql:5.7 为例。不同的版本可能有一定的出入，需要详细去阅读官方文档。脚本如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>FROM mysql:5.7\nLABEL OG=felord.cn\nCOPY utf8mb4.cnf /etc/mysql/conf.d/utf8mb4.cnf\nCOPY ./sql  /tmp/sql\nRUN mv /tmp/sql/*.sql /docker-entrypoint-initdb.d\nRUN rm -rf /tmp/sql\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>第一步，引入官方 Mysql:5.7 Docker镜像。</li><li>第二步，无实际意义，主要是作者、组织信息。</li><li>第三步，很重要！本来我没有配置第三行，结果运行容器后发现初始化数据的中文全部乱码了。所以需要在初始化数据库前修改Mysql的编码等配置，这里我顺便把时区也改为了+8:00。</li><li>第四步，复制包含数据库脚本的 ./sql文件夹到镜像的/tmp/sql下。</li><li>第五步，使用 mv 命令把第四步拷贝的文件夹下的所有.sql文件复制到 /docker-entrypoint-initdb.d下，这样才能利用2.章节的机制进行初始化数据库。</li><li>第六步，删除使用过的临时目录。</li></ul><p>然后你可以通过构建镜像命令构建自定义的Mysql镜像：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 一定不要忘记最后的一个 . 点</span>\ndocker build -t mysql:5.7c <span class="token builtin class-name">.</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>通过 mysql:5.7c 镜像启动一个名称为 mysql-service 的容器，root 密码为 123456，并持久化数据到宿主机 D:/mysql/data 下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run --name mysql-service -v d:/mysql/data:/var/lib/mysql -p <span class="token number">3306</span>:3306 -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> -d mysql:5.7c\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>小贴士：你可以通过 SHOW VARIABLES LIKE &#39;character%&#39; 查看字符集是否更改为utf8mb4,也可以通过SHOW VARIABLES LIKE &#39;%time_zone%&#39; 查看时区是否是东八区。</p><h2 id="docker-的宿主系统是-centos-为什么可以运行-ubuntu-的镜像呢" tabindex="-1"><a class="header-anchor" href="#docker-的宿主系统是-centos-为什么可以运行-ubuntu-的镜像呢" aria-hidden="true">#</a> docker 的宿主系统是 centos，为什么可以运行 ubuntu 的镜像呢？</h2><p>首先需要区分Linux内核与Linux发行版</p><ul><li><p>Linux内核是Linux操作系统的核心, 负责硬件管理, 比如管理内存、管理磁盘（文件系统）、管理CPU(进程)等等...</p></li><li><p>Linux发行版是在Linux内核的基础上添加了一些工具软件,比如图形界面、函数库、软件包管理系统等等...</p></li></ul><p>CentOS与Ubuntu是不同的Linux发行版, 它们都是基于Linux内核， 只是添加的工具软件不同。比如， 他们的软件包管理系统不同， CentOS使用yum命令安装软件， 而Ubuntu使用apt-get命令安装软件。</p><p>因此CentOS与Ubuntu的内核是相同的(版本可能不同), 只是所安装的软件不同， 即文件系统不同。</p><p>Docker容器技术是基于Linux内核实现的， 它主要用到了两个内核模块:</p><ul><li><p>Namespace： 用于容器的隔离， 例如PID Namespace使得容器中的进程无法感知宿主机以及其他容器中的进程。</p></li><li><p>Cgroups: 用于容器的资源控制， 比如限制容器所使用的内存大小或者CPU个数。</p></li></ul><p>在CentOS上运行基于Ubuntu镜像的容器时, 容器使用了CentOS主机的内核以及Ubuntu镜像, Ubuntu镜像中安装了Ubuntu的各种软件(apt-get)。</p>',23),u={render:function(e,n){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[l,(0,a._)("p",null,[r,(0,a._)("a",i,[t,(0,a.Wm)(s)]),c]),d],64)}}}}]);