"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[6927],{79196:(e,t,n)=>{n.r(t),n.d(t,{data:()=>a});const a={key:"v-11610f68",path:"/docker/06-Dockerfile.html",title:"Dockerfile",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"指令说明",slug:"指令说明",children:[{level:3,title:"FROM",slug:"from",children:[]},{level:3,title:"MAINTAINER",slug:"maintainer",children:[]},{level:3,title:"ENV",slug:"env",children:[]},{level:3,title:"RUN",slug:"run",children:[]},{level:3,title:"ADD 和 COPY",slug:"add-和-copy",children:[]},{level:3,title:"WORKDIR",slug:"workdir",children:[]},{level:3,title:"EXPOSE",slug:"expose",children:[]},{level:3,title:"CMD",slug:"cmd",children:[]},{level:3,title:"ENTRYPOINT",slug:"entrypoint",children:[]}]},{level:2,title:"示例",slug:"示例",children:[]}],filePathRelative:"docker/06-Dockerfile.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},51309:(e,t,n)=>{n.r(t),n.d(t,{default:()=>s});const a=(0,n(66252).uE)('<h1 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile" aria-hidden="true">#</a> Dockerfile</h1><p>Dockerfile 是用来描述文件的构成的文本文档，其中包含了用户可以在使用行调用以组合 Image 的所有命令，用户还可以使用Docker build 实现连续执行多个命令指今行的自动构建。</p><p>通过编写 Dockerfile 生成镜像，可以为开发、测试团队提供基本一致的环境，从而提升开发、测试团队的效率，不用再为环境不统一而发愁，同时运维也能更加方便地管理我们的镜像。</p><p>Dockerfile 的语法非常简单，常用的只有11个：</p><table><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">FROM</td><td style="text-align:left;">基于哪个镜像来实现</td></tr><tr><td style="text-align:left;">MAINTAINER</td><td style="text-align:left;">镜像的作者</td></tr><tr><td style="text-align:left;">ENV</td><td style="text-align:left;">声明环境变量</td></tr><tr><td style="text-align:left;">RUN</td><td style="text-align:left;">执行命令</td></tr><tr><td style="text-align:left;">ADD</td><td style="text-align:left;">添加宿主机文件到容器里，\\n有需要解压的文件会自动解压</td></tr><tr><td style="text-align:left;">COPY</td><td style="text-align:left;">添加宿主机文件到容器里</td></tr><tr><td style="text-align:left;">WORKDIR</td><td style="text-align:left;">工作目录</td></tr><tr><td style="text-align:left;">EXPOSE</td><td style="text-align:left;">容器内应用可使用端口</td></tr><tr><td style="text-align:left;">CMD</td><td style="text-align:left;">容器启动后所执行的程序。\\n如果执行 docker run 后面跟启动命令会被覆盖掉</td></tr><tr><td style="text-align:left;">ENTRYPOINT</td><td style="text-align:left;">与 CMD 功能相同，但是 docker run 不会覆盖。\\n如果需要覆盖可增加参数 --entrypoint 来覆盖</td></tr><tr><td style="text-align:left;">VOLUME</td><td style="text-align:left;">将宿主机容器的目录挂载到容器里</td></tr></tbody></table><h2 id="指令说明" tabindex="-1"><a class="header-anchor" href="#指令说明" aria-hidden="true">#</a> 指令说明</h2><h3 id="from" tabindex="-1"><a class="header-anchor" href="#from" aria-hidden="true">#</a> FROM</h3><p>两种形式如下：</p><pre><code>FROM &lt;IMAGE&gt;\nFROM &lt;IMAGE&gt;:&lt;TAG&gt;\n</code></pre><p>通过 FROM 指定的镜像名称必须是一个已经存在的镜像，这个镜像称之为基础镜像，必须位于第一条非注释指令。</p><h3 id="maintainer" tabindex="-1"><a class="header-anchor" href="#maintainer" aria-hidden="true">#</a> MAINTAINER</h3><pre><code>MAINTAINER &lt;NAME&gt;\n</code></pre><p>指定镜像的作者信息，包含镜像的所有者和联系人信息。</p><h3 id="env" tabindex="-1"><a class="header-anchor" href="#env" aria-hidden="true">#</a> ENV</h3><p>用于设置环境变量</p><pre><code>ENV &lt;KEY&gt; &lt;VALUE&gt;\nENV &lt;KEY&gt;=&lt;VALUE&gt;\n</code></pre><h3 id="run" tabindex="-1"><a class="header-anchor" href="#run" aria-hidden="true">#</a> RUN</h3><p>用于指定构建镜像时运行的命令，两种模式：</p><pre><code>shell 模式：\nRUN &lt;command&gt; \n\nexec 模式：\nRUN [ &quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ] \n</code></pre><p>在 shell 模式下，是使用 <strong>/bin/sh -c COMMAND</strong> 来运行命令的在 exec 模式下可以指定其他的 shell 来运行命令 <strong>RUN [“/bin/bash”, “-c”, “echo hello”]</strong> 。</p><p>多条 RUN 指令可以合并为一条，例如：</p><pre><code>RUN yum install httpd &amp;&amp; yum install ftp\n</code></pre><p>这样在构建的时候会减少产生中间层镜像。</p><h3 id="add-和-copy" tabindex="-1"><a class="header-anchor" href="#add-和-copy" aria-hidden="true">#</a> ADD 和 COPY</h3><p>作用都是将文件或目录复制到 Dockerfile 构建的镜像中。</p><pre><code>ADD &lt;src&gt; &lt;dest&gt;\nADD [&quot;&lt;src&gt;&quot; &quot;&lt;dest&gt;&quot;] \n适用于文件路径包含空格的情况\n\nCOPY &lt;src&gt; &lt;dest&gt;\nADD [&quot;&lt;src&gt;&quot; &quot;&lt;dest&gt;&quot;] \n适用于文件路径包含空格的情况\n</code></pre><p>ADD 包含了类似 tar 的解压功能，如果只是单纯复制文件，建议使用 COPY，而且，两者的源文件路径使用Dockerfile相对路径，目标路径使用绝对路径。</p><pre><code>COPY index.html /var/www/html\n</code></pre><h3 id="workdir" tabindex="-1"><a class="header-anchor" href="#workdir" aria-hidden="true">#</a> WORKDIR</h3><p>在容器内部设置工作目录，这样 ENTRYPOINT 和 CMD 指定的命令都会在容器中这个目录下进行。</p><pre><code>WORKDIR /path/to/workdir\n</code></pre><h3 id="expose" tabindex="-1"><a class="header-anchor" href="#expose" aria-hidden="true">#</a> EXPOSE</h3><p>指定运行该镜像的容器使用的端口，可以是多个。</p><pre><code>EXPOSE &lt;PORT&gt;\n</code></pre><p>使用这个指令的目的是告诉应用程序容器内应用程序会使用的端口，在运行时还需要使用 -p 参数指定映射端口。这是 docker 处于安全的目的，不会自动打开端口。</p><h3 id="cmd" tabindex="-1"><a class="header-anchor" href="#cmd" aria-hidden="true">#</a> CMD</h3><p>用于提供容器运行的默认命令，如果在 docker run 时指定了运行的命令，则 CMD 命令不会执行。</p><p>CMD 有三种模式：</p><pre><code>CMD &lt;command&gt; (shell模式)\n\nexec 模式\nCMD [ &quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ] \n\n通常与 ENTRYPOINT 搭配指定 ENTRYPOINT 的默认参数\nCMD [ &#39;param1&#39;, &#39;param2&#39;] \n</code></pre><h3 id="entrypoint" tabindex="-1"><a class="header-anchor" href="#entrypoint" aria-hidden="true">#</a> ENTRYPOINT</h3><p>与 CMD 类似，ENTRYPOINT 不会被 <strong>docker run</strong> 中指定的命令覆盖，如果想覆盖 ENTRYPOINT，则需要在 <strong>docker run</strong> 中指定 --entrypoint 选项。</p><p>它有两种模式：</p><pre><code>shell 模式\nENTRYPOINT &lt;command&gt; \n\nexec 模式\nENTRYPOINT [ &quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ] \n</code></pre><p>###0 VOLUME</p><p>用于向容器添加卷，可以提供共享存储等功能</p><pre><code>VOLUME [&#39;/data&#39;]\n</code></pre><h2 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h2><p>Dockerfile ⽂件格式如下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">##Dockerfile ⽂件格式</span>\n<span class="token comment"># This dockerfile uses the ubuntu image</span>\n<span class="token comment"># VERSION 2 - EDITION 1</span>\n<span class="token comment"># Author: docker_user</span>\n<span class="token comment"># Command format: Instruction [arguments / command] ..</span>\n\n<span class="token comment"># (1) 第⼀⾏必须指定基础镜像信息</span>\nFROM ubuntu\n\n<span class="token comment"># (2) 维护者信息</span>\nMAINTAINER docker_user docker_user@email.com\n\n<span class="token comment"># (3) 镜像操作指令</span>\nRUN <span class="token builtin class-name">echo</span> <span class="token string">&quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot;</span> <span class="token operator">&gt;&gt;</span> /etc/apt/sources.list\nRUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y nginx\nRUN <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token entity" title="\\n">\\n</span>daemon off;&quot;</span> <span class="token operator">&gt;&gt;</span> /etc/nginx/nginx.conf\n\n<span class="token comment"># (4) 容器启动执⾏指令</span>\nCMD /usr/sbin/nginx\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>Dockerfile 分为四部分：<strong>基础镜像信息</strong>、<strong>维护者信息</strong>、<strong>镜像操作指令</strong>、<strong>容器启动执⾏指令</strong> 。</p><ul><li><p>⼀开始必须要指明所基于的镜像名称，</p></li><li><p>接下来⼀般会说明维护者信息；</p></li><li><p>后⾯则是镜像操作指令，如 RUN 指令。每执⾏⼀条 RUN 指令，镜像添加新的⼀层，并提交；</p></li><li><p>最后是 CMD 指令，来指明运⾏容器时的操作命令。</p></li></ul>',51),s={render:function(e,t){return a}}}}]);