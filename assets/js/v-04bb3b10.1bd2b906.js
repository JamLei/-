"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[6884],{83060:(e,n,t)=>{t.r(n),t.d(n,{data:()=>s});const s={key:"v-04bb3b10",path:"/css/11-Flex.html",title:"Flex 布局",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"i1.1. 前言/历史",slug:"i1-1-前言-历史",children:[]},{level:2,title:"11.2. Flex 布局是什么？",slug:"_11-2-flex-布局是什么",children:[]},{level:2,title:"11.3. 基本概念",slug:"_11-3-基本概念",children:[]},{level:2,title:"11.4. flex 容器的核心属性",slug:"_11-4-flex-容器的核心属性",children:[{level:3,title:"4.1 flex-direction 属性",slug:"_4-1-flex-direction-属性",children:[]},{level:3,title:"4.2 flex-wrap 属性",slug:"_4-2-flex-wrap-属性",children:[]},{level:3,title:"4.3 flex-flow 属性（选学）",slug:"_4-3-flex-flow-属性-选学",children:[]},{level:3,title:"4.4 justify-content 属性",slug:"_4-4-justify-content-属性",children:[]},{level:3,title:"4.5 align-items 属性",slug:"_4-5-align-items-属性",children:[]}]},{level:2,title:"11.5. align-content 属性",slug:"_11-5-align-content-属性",children:[]}],filePathRelative:"css/11-Flex.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},99215:(e,n,t)=>{t.r(n),t.d(n,{default:()=>a});const s=(0,t(66252).uE)('<h1 id="flex-布局" tabindex="-1"><a class="header-anchor" href="#flex-布局" aria-hidden="true">#</a> Flex 布局</h1><h2 id="i1-1-前言-历史" tabindex="-1"><a class="header-anchor" href="#i1-1-前言-历史" aria-hidden="true">#</a> i1.1. 前言/历史</h2><p>网页布局（layout）是 CSS 的一个重点应用。布局最核心的问题是：<strong>如何在一行中显示两个 block 元素？</strong></p><p>从历史发展的时间顺序来看，解决这个问题的方案有三种：</p><ul><li><p>使用 <strong>&lt;table&gt;</strong> 元素布局；</p></li><li><p>使用 <strong>position:static</strong> + <strong>float</strong> 布局；</p></li><li><p>使用 <strong>position:relative</strong> + <strong>position: absolute</strong> 布局。</p></li></ul><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/div_0.jpg" alt=""></p><blockquote><p><small>语义化是 HTML5 的一个重点，例如它提出 <code>&lt;strong&gt;</code> 来替代 <code>&lt;b&gt;</code>。对于常用于布局的无语义的 <code>&lt;div&gt;</code> 元素，HTML5 也提出了几个替代它的语义化元素：</small></p></blockquote><p>历史上，在经历了上述三种方案的发展之后，W3C 组织最终提出了一个统一的标准的解决方案：<em><strong><code>Flex</code></strong></em> 布局。</p><h2 id="_11-2-flex-布局是什么" tabindex="-1"><a class="header-anchor" href="#_11-2-flex-布局是什么" aria-hidden="true">#</a> 11.2. Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局。</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>行内元素也可以使用 Flex 布局。</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> inline-flex<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p><em><code>flex</code></em> 和 <em><code>inline-flex</code></em> 的区别在于，上述例子中的 flex 类型的 .box 是独占一行，而 inline-flex 的 .box 不要求独占一行。</p></blockquote><p>注意，父元素的 <em><strong><code>display</code></strong></em> 设为 <em><strong><code>flex</code></strong></em> 以后，其子元素的 <em><strong><code>float</code></strong></em>、<em><strong><code>clear</code></strong></em> 和 <em><strong><code>vertical-align</code></strong></em> 属性将失效。</p><h2 id="_11-3-基本概念" tabindex="-1"><a class="header-anchor" href="#_11-3-基本概念" aria-hidden="true">#</a> 11.3. 基本概念</h2><p>采用 flex 布局的元素，称为 flex 容器（flex container），简称【容器】。它的所有子元素自动成为容器成员，称为 flex 项目（flex item），简称【项目】。</p><p>一个 flex 容器中默认存在两根轴：主轴（main axis）和交叉轴（cross axis）。主轴和交叉轴成 90° 垂直交叉，<small>这也是为什么第二根轴被称为【交叉】轴的原因。</small></p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-01.png" alt="flex-01"></p><p>默认情况下，主轴是水平的，方向是从左往右，那么交叉轴自然就是垂直的。毫无疑问，主轴是水平还是交叉，以及它的方向是 <strong>可以设置</strong> 的 。</p><blockquote><p>注意，主轴的相关属性会影响到交叉轴，但是反之，交叉轴影响不到主轴。</p></blockquote><p>无论水平还是垂直，主轴的开始位置（与边框的交叉点）被称作 <strong>主轴的起点</strong><small>（main start）</small>，与之对应的，结束的位置被称作 <strong>主轴的终点</strong><small>（main end）</small>。同样，交叉轴也有起点和终点的概念。</p><p>主轴水平时：</p><ul><li>如果方向是从左往右，那么，毫无疑问，主轴的起点在左边线，终点在右边线。</li><li>如果方向是从右往左，那么，毫无疑问，主轴的起点在右边线，终点在左边线。</li><li>主轴水平，那么交叉轴必然是垂直。此时，无论主轴是从左往右，还是从右往左，<span class="strong">交叉轴的方向都是从上往下</span>。那么，毫无疑问，交叉轴的起点在上边线，终点在下边线。</li><li><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-02.png" alt="flex-02"></li></ul><p>主轴垂直时：</p><ul><li>如果方向是从上往下，那么，毫无疑问，主轴的起点在上边线，终点在下边线。</li><li>如果方向是从下往上，那么，毫无疑问，主轴的起点在下边线，终点在上边线。</li><li>主轴垂直，那么交叉轴必然是水平。此时，无论主轴是从上往下，还是从下往上，<span class="strong">交叉轴的方向都是从左往右</span>。那么，毫无疑问，交叉轴的起点在左边线，终点在右边线。</li><li><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-03.png" alt="flex-03"></li></ul><h2 id="_11-4-flex-容器的核心属性" tabindex="-1"><a class="header-anchor" href="#_11-4-flex-容器的核心属性" aria-hidden="true">#</a> 11.4. flex 容器的核心属性</h2><p>常见有以下 4 个属性设置在容器上。</p><ul><li>flex-direction</li><li>flex-wrap</li><li>justify-content</li><li>align-items</li></ul><h3 id="_4-1-flex-direction-属性" tabindex="-1"><a class="header-anchor" href="#_4-1-flex-direction-属性" aria-hidden="true">#</a> 4.1 flex-direction 属性</h3><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">flex-direction</span><span class="token punctuation">:</span> row | row-reverse | column | column-reverse<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>默认值为 <strong>row</strong> 。</p><p><strong>flex-direction</strong> 属性控制着主轴的水平/垂直，以及方向。</p><ul><li><p><code>flex-direction: row</code></p><p>主轴水平，方向是从左往右。主轴起点在左，终点在右。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-04.png" alt="flex-04"></p><p><small>此时，交叉轴自然就是垂直，方向是从上往下。</small></p></li><li><p><code>flex-direction: row-reverse</code></p><p>主轴水平，方向是从右往左。主轴起点在右，终点在左。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-05.png" alt="flex-05"></p><p><small>此时，交叉轴自然就是垂直，方向仍然是从上往下。</small></p></li><li><p><code>flex-direction: column</code></p><p>主轴垂直，方向是从上往下。主轴起点在上，终点在下。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-06.png" alt="flex-06"></p><p><small>此时，交叉轴自然就是水平，方向是从左往右。</small></p></li><li><p><code>flex-direction: column-reverse</code></p><p>主轴垂直，方向是从下往上。主轴起点在下，终点在上。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-07.png" alt="flex-07"></p><p><small>此时，交叉轴自然就是水平，方向仍然是从左往右。</small></p></li></ul><h3 id="_4-2-flex-wrap-属性" tabindex="-1"><a class="header-anchor" href="#_4-2-flex-wrap-属性" aria-hidden="true">#</a> 4.2 flex-wrap 属性</h3><p>默认情况下，flex 元素的子元素<small>（item）</small>都【串】在主轴上<small>（无论主轴是水平还是垂直）</small>。</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">flex-wrap</span><span class="token punctuation">:</span> nowrap | wrap | wrap-reverse<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>flex-wrap</strong> 属性定义，如果一条轴线排不下，如何换行。</p><p>默认值为 <em><strong><code>nowrap</code></strong></em> 。</p><ul><li><p><code>flex-wrap: nowrap</code></p><p><em><strong><code>nowrap</code></strong></em> 表示不换行，即，flex 元素的所有子元素，都要在同一行。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-08.png" alt="flex-08"></p></li><li><p><code>flex-wrap: wrap</code></p><p>表示换行，换行的方向是沿交叉轴方向换行。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-09.png" alt="flex-09"></p><p>这里是以 <code>flex-direction: row</code> 为例，这种情况下，交叉轴的方向是从上往下的。因此，换行时，第二行就在第一行的【下】面。</p></li><li><p><code>flex-wrap: wrap-reverse</code></p><p>表示逆向换行，换上的方向是【逆】交叉轴方向。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-10.png" alt="flex-10"></p><p>由于这里交叉轴的方向是从上往下，因此，逆向换行时，第二行就在第一行的【上】面。</p></li></ul><blockquote><p>注意，上面的三个例子，都是以 <code>flex-direction: row</code> 为样本进行的举例。当 <code>flex-direction</code> 属性值为其它值时，相关概念是一样的。</p></blockquote><h3 id="_4-3-flex-flow-属性-选学" tabindex="-1"><a class="header-anchor" href="#_4-3-flex-flow-属性-选学" aria-hidden="true">#</a> 4.3 flex-flow 属性（选学）</h3><p>flex-flow 属性不是【新】属性，它是 <em><strong><code>flex-direction + flex-wrap</code></strong></em> 属性的简写形式。默认值为 <em><strong><code>row nowrap</code></strong></em>。</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">flex-flow</span><span class="token punctuation">:</span> &lt;flex-direction&gt; || &lt;flex-wrap&gt;<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_4-4-justify-content-属性" tabindex="-1"><a class="header-anchor" href="#_4-4-justify-content-属性" aria-hidden="true">#</a> 4.4 justify-content 属性</h3><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><em><strong><code>justify-content</code></strong></em> 属性定义了项目在主轴上的对齐方式。</p><table><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><code>flex-start</code></td><td style="text-align:left;">默认值，靠近主轴的起点位置</td></tr><tr><td style="text-align:left;"><code>flex-end</code></td><td style="text-align:left;">靠近主轴的终点位置</td></tr><tr><td style="text-align:left;"><code>center</code></td><td style="text-align:left;">居中</td></tr><tr><td style="text-align:left;"><code>space-between</code></td><td style="text-align:left;">起点-终点两端对齐，<br>子元素间均分空白。</td></tr><tr><td style="text-align:left;"><code>space-around</code></td><td style="text-align:left;">和 <code>space-between</code> 类似。<br>不过起点-终点和边框间有间距。<br>这个间距等于 1/2 的子元素间的间距。</td></tr></tbody></table><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-11.png" alt="flex-11"></p><blockquote><p>注意，这里是以 <code>flex-direction: row</code> 为样本进行的举例。当 <code>flex-direction</code> 属性值为其它值时，相关概念是一样的。</p></blockquote><h3 id="_4-5-align-items-属性" tabindex="-1"><a class="header-anchor" href="#_4-5-align-items-属性" aria-hidden="true">#</a> 4.5 align-items 属性</h3><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">align-items</span><span class="token punctuation">:</span> flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><em><strong><code>align-items</code></strong></em> 属性定义 flex 元素的子元素（item）在交叉轴上如何对齐。</p><p>它可能取 5 个值。</p><table><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><code>flex-start</code></td><td style="text-align:left;">所有子元素都对齐交叉轴的起点。</td></tr><tr><td style="text-align:left;"><code>flex-end</code></td><td style="text-align:left;">所有子元素都对齐交叉轴的终点。</td></tr><tr><td style="text-align:left;"><code>center</code></td><td style="text-align:left;">所有子元素都对齐交叉轴中点。</td></tr><tr><td style="text-align:left;"><code>baseline</code></td><td style="text-align:left;">以所有子元素的第一行文字的基线对齐。</td></tr><tr><td style="text-align:left;"><code>stretch</code></td><td style="text-align:left;">默认值。<br>如果子元素自身未设置高度或设为 auto，那么子元素将被拉伸，以便同时对齐交叉轴的起点和终点。</td></tr></tbody></table><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-12.png" alt="flex-12"></p><blockquote><p>注意，这里是以 <code>flex-direction: row</code> 为样本进行的举例。当 <code>flex-direction</code> 属性值为其它值时，相关概念是一样的。</p></blockquote><h2 id="_11-5-align-content-属性" tabindex="-1"><a class="header-anchor" href="#_11-5-align-content-属性" aria-hidden="true">#</a> 11.5. align-content 属性</h2><p><em><strong><code>align-content</code></strong></em> 属性和 <em><code>flex-wrap</code></em> 属性有点关系。当 <em><code>flex-wrap: wrap</code></em> 和 <em><code>flex-wrap:wrap-reverse</code></em> 时，如果 Flex 元素的子元素（item）多到一行/一列放不下时，会出现折行的情况。这时，逻辑上就相当于有了多根平行的主轴。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/flex-09.png" alt="flex-09"></p><p><em><strong><code>align-content</code></strong></em> 属性就是用来设置这多根平行的主轴在交叉轴方向上的对齐方式。</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">align-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around | stretch<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>注意，如果项目只有一根轴线，该属性不起作用。</p></blockquote><ul><li><p><code>align-content: flex-start</code></p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/align-content-flex-start.png" alt="align-content-flex-start.png"></p><p>如上例，三根主轴轴线紧靠在一起，整体对齐交叉轴的起点位置。</p></li><li><p><code>align-content: flex-end</code></p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/align-content-flex-end.png" alt="align-content-flex-end.png"></p><p>如上例，三根主轴轴线紧靠在一起，整体对齐交叉轴的终点位置。</p></li><li><p><code>align-content: flex-center</code></p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/align-content-center.png" alt="align-content-center.png"></p><p>如上例，三根主轴轴线紧靠在一起，在交叉轴方上居中，即交叉轴的起点和终点位置时留白。</p></li><li><p><code>align-content: space-between</code></p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/align-content-between.png" alt="align-content-between.png"></p><p>如上例，三根主轴轴线之间有等宽的间隔，同时，第一根轴对齐交叉轴的起点，最后一根轴对齐交叉轴的终点。</p><p>上面这个图例优点小瑕疵，【对齐】表现得不明显。</p></li><li><p><code>align-content: space-around</code></p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/align-content-around.png" alt="align-content-around.png"></p><p>如上例，三根主轴轴线之间有等宽的间隔，同时，第一根轴和交叉轴的起点有间隔，最后一根轴和交叉轴的终点有间隔，这个【间隔】等于轴与轴之间的间距的 1/2 。</p></li><li><p><code>align-content: stretch</code></p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/css/img/align-content-stretch.png" alt="align-content-stretch.png"></p><p>这是默认值。每根主轴上的元素（item）会被拉伸，逻辑上，各个主轴一起均分交叉轴方向上的空间。前提是主轴上的元素没有指定明确的长度，或者为 auto 。</p><p>不过，各个主轴之间也有间隙，整体呈 <code>主轴-间隙-主轴-间隙-...</code> 的形式。因此，第一根主轴是对齐交叉轴起点位置，而最后一根轴和交叉轴终点位置之间有间隙。</p></li></ul>',65),a={render:function(e,n){return s}}}}]);