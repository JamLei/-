"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[8006],{49158:(t,n,a)=>{a.r(n),a.d(n,{data:()=>l});const l={key:"v-0cf397ac",path:"/java-thread/thread-01-base.html",title:"多线程：基础",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"认识线程",slug:"认识线程",children:[]},{level:2,title:"线程",slug:"线程",children:[]},{level:2,title:"使用 Thread 类创建线程",slug:"使用-thread-类创建线程",children:[]},{level:2,title:"使用 Runnable 接口创建线程",slug:"使用-runnable-接口创建线程",children:[]},{level:2,title:"线程的状态",slug:"线程的状态",children:[]},{level:2,title:"线程的调用",slug:"线程的调用",children:[{level:3,title:"线程的优先级（了解、自学）",slug:"线程的优先级-了解、自学",children:[]},{level:3,title:"实现线程调度的方法",slug:"实现线程调度的方法",children:[]},{level:3,title:"线程的同步与互斥",slug:"线程的同步与互斥",children:[]},{level:3,title:"synchronized 关键字",slug:"synchronized-关键字",children:[]}]},{level:2,title:"锁",slug:"锁",children:[]}],filePathRelative:"java-thread/thread-01-base.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},23738:(t,n,a)=>{a.r(n),a.d(n,{default:()=>e});const l=(0,a(66252).uE)('<h1 id="多线程-基础" tabindex="-1"><a class="header-anchor" href="#多线程-基础" aria-hidden="true">#</a> 多线程：基础</h1><h2 id="认识线程" tabindex="-1"><a class="header-anchor" href="#认识线程" aria-hidden="true">#</a> 认识线程</h2><p>现代化操作系统都是采用『<strong>多任务</strong>』和『<strong>分时</strong>』设计，从而诞生了『<strong>程序</strong>』和『<strong>进程</strong>』的概念，而后又进一步诞生了『<strong>线程</strong>』的概念。</p><blockquote><p>从历史的时间线来看，『<strong>进程</strong>』在前，『<strong>线程</strong>』在后。</p></blockquote><p>『<strong>程序</strong>』是对数据描述与操作的代码的集合。</p><p>『<strong>进程</strong>』是程序的一次动态执行的过程，它对应了从代码加载、执行至执行完毕的一个完整过程。这个过程也是进程从产生、发展至消亡的过程。</p><blockquote><p>通俗地说，『程序』是死的，『进程』是活的。进程就是『<strong>活着的</strong>』程序。</p></blockquote><p>『<strong>运行程序</strong>』也被称作『<strong>执行任务</strong>』,一个操作系统中可以同时运行多个程序也就是同时执行『<strong>多个任务</strong>』，那么每个任务就对应一个进程。</p><p>在操作系统的管控下，多个进程『<strong>轮流</strong>』使用 CPU 资源<small>（和其他公共资源）</small>，这被称作『<strong>分时</strong>』。</p><blockquote><p>通俗地说，站在 CPU 的角度而言，<strong>根本不存在所谓的同时</strong>。这一点很重要。</p></blockquote><p>进程的特点：</p><ul><li><p>进程是操作系统运行程序的基本单元；</p></li><li><p>每一个进程都有自己独立的一块内存空间和一组系统资源；</p></li><li><p>每一个进程的内部数据和状态是完全独立的。</p></li></ul><h2 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h2><p>『线程』是更现代化的概念和技术<small>（它的诞生晚于进程）</small>。线程是『<strong>进程中</strong>』的一个单位，即，一个进程可以有多个线程<small>（至少有一个），简单来说，就是 <code>一对多</code> 的关系</small>。</p><p>线程是进程中执行运算的最小单元，一个进程在其执行过程中可以产生多个线程，而线程必须在某个进程内执行。</p><p>线程是进程内部的一个执行单元，是可以完成一个独立任务的顺序控制流程。如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为『<strong>多线程</strong>』。</p><p>线程和进程既有联系又有区别：</p><ul><li><p>一个进程中至少要有一个线程；</p></li><li><p>操作系统将资源分配给进程，同一个进程的所有线程共享该进程的所有资源；</p></li><li><p>操作系统将 CPU 分配给线程，即真正在 CPU 上运行的上线程。</p></li></ul><p><strong>每个线程都有一个『执行方法』</strong><small>（也叫『<strong>入口方法</strong>』）</small>，每个进程至少拥有的、自动拥有的那个线程的执行方法毫无疑问就是 <strong>main</strong> 方法，因此这个线程也被成为『<strong>主线程</strong>』。</p><p>每个线程的任务、使命就是去执行它的执行方法。<small>线程的执行方法的结束，即意味着线程的生命、使命的完结。</small></p><p>创建并使用线程的过程可以分为 4 个步骤：</p><ol><li><p>定义一个线程类，同时指明这个线程的执行方法</p></li><li><p>创建线程对象</p></li><li><p>启动线程</p></li><li><p>终止线程</p></li></ol><p>定义一个线程类通常有两种方法：继承 <strong>java.lang.Thread</strong> 类和实现 <strong>java.lang.Runnable</strong> 接口。</p><h2 id="使用-thread-类创建线程" tabindex="-1"><a class="header-anchor" href="#使用-thread-类创建线程" aria-hidden="true">#</a> 使用 Thread 类创建线程</h2><p>Java 提供了 java.lang.Thread 类支持多线程编程，该类提供了大量的方法来控制和操作线程。</p><table><thead><tr><th style="text-align:left;">#</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">run 方法</td><td style="text-align:left;">直接调用线程的执行函数</td></tr><tr><td style="text-align:left;">start 方法</td><td style="text-align:left;">启动线程</td></tr><tr><td style="text-align:left;">sleep 方法</td><td style="text-align:left;">让线程休眠<small>（即让出 CPU）</small>指定 <strong>毫秒</strong> 数</td></tr><tr><td style="text-align:left;">getName 方法</td><td style="text-align:left;">返回该线程的名称</td></tr><tr><td style="text-align:left;">getPriority 方法</td><td style="text-align:left;">返回线程的优先级</td></tr><tr><td style="text-align:left;">setPriority 方法</td><td style="text-align:left;">更改线程的优先级</td></tr><tr><td style="text-align:left;">getState 方法</td><td style="text-align:left;">返回该线程的状态</td></tr><tr><td style="text-align:left;">isAlive 方法</td><td style="text-align:left;">测试线程是否处于活动状态</td></tr><tr><td style="text-align:left;">join 方法</td><td style="text-align:left;">等待该线程终止</td></tr><tr><td style="text-align:left;">interrupt 方法</td><td style="text-align:left;">中断线程</td></tr><tr><td style="text-align:left;">yield 方法</td><td style="text-align:left;">暂停正在执行的线程，并执行其他线程</td></tr></tbody></table><p>使用继承 Thread 类的方式创建线程的实现步骤如下：</p><ol><li><p>定义一个类去继承 Thread 类，重写 <strong>Thread#run</strong> 方法，在 <strong>Thread#run</strong> 方法中实现代码逻辑；</p></li><li><p>创建线程对象;</p></li><li><p>调用 <strong>Thread#start</strong> 方法启动线程。</p></li></ol><h2 id="使用-runnable-接口创建线程" tabindex="-1"><a class="header-anchor" href="#使用-runnable-接口创建线程" aria-hidden="true">#</a> 使用 Runnable 接口创建线程</h2><p>由于 Java 只允许单继承，因此一旦一个类已有父类，那么就无法再继承 Thread 类，从而导致上述实现线程的方式无法使用。</p><p>使用 Runnable 接口创建线程能解决上述问题。</p><p>Runnable 接口声明了一个 <strong>Runnable#run</strong> 方法。任何一个类都可以通过实现 Runnable 接口并实现其 <strong>Runnable#run</strong> 方法来完成线程的所有活动。</p><p>使用实现 Runnable 接口的方式创建线程的实现步骤如下：</p><ol><li><p>定义 Xxx 类并实现 java.lang.Runnable 接口，并实现它所声明的 <strong>run</strong> 方法；</p></li><li><p>创建线程对象；</p></li><li><p>调用 <strong>start</strong> 方法启动线程。</p></li></ol><h2 id="线程的状态" tabindex="-1"><a class="header-anchor" href="#线程的状态" aria-hidden="true">#</a> 线程的状态</h2><p>线程的核心状态有 3 个：</p><ul><li>可执行<small>（Runnable）</small></li><li>执行中<small>（Running）</small></li><li>阻塞中<small>（Blocking）</small></li></ul><p>在加上线程创建之处的短暂的『新生』状态<small>（Created）</small>和销毁前的短暂的『僵尸』状态<small>（Zombie）</small>，从而组成了最常见的线程的 5 种状态。</p><dl><dt>新生状态：Created</dt><dd>创建线程对象后，而又未调用其 Thread#start 方法之前，该线程处于这种状态。此时操作系统还未为其分配资源。</dd><dd>此时只能启动和终止线程，任何而其他操作都会发生议程。</dd></dl><dl><dt>可执行状态：Runnable</dt><dd>当调用 Thread#start 之后，操作系统为该线程分配了所必须的资源，但是而又未获得 CPU 执行机会时，该线程处于这种状态。</dd><dd>由于 CPU 时稀缺的公共资源，毫无疑问，在多线程程序中，任意时刻有大量的线程都是处于这种状态。</dd><dd>通俗的说，这种状态就是『万事俱备，只欠东风』。</dd></dl><dl><dt>执行状态：Running</dt><dd>当前获得 CPU 资源，正在执行的线程，就是处于这种状态。</dd><dd>对于单核 CPU 而言，一个进程中无论有多少线程，任意时刻有且仅有一个线程是处于该状态。</dd><dd>同理，对于多核 CPU 而言，<small>（全系统无论多少进程多少线程）</small>N 核 CPU 有且仅有 N 个线程处于这种状态。</dd></dl><dl><dt>阻塞状态：Blocked</dt><dd>一个正在运行（Running）的线程因为某种原因代码逻辑无法再继续运行下去了，就进入阻塞状态。</dd><dd>进入阻塞状态的线程会让出 CPU，因为即便它强占 CPU 也无法再继续运行下去。</dd><dd>当造成该线程阻塞的原因小时后，该线程将又有机会运行。</dd><dd>通俗的说，这种状态就是『除了欠东风，还欠别的』。</dd></dl><p>导致一个线程阻塞最常见的原因有以下几个：</p><ul><li><p>调用了 Thread 类的静态方法 Thread#sleep ;</p></li><li><p>线程执行 IO 时，无数据可读（或无空间可写）；</p></li><li><p>一个线程的执行需要获得一个『锁』，而此时锁正被别的线程占用。</p></li></ul><dl><dt>僵尸状态：Zombie</dt><dd>一个线程在结束执行后（无论是正常执行完执行函数，还是被终止掉了），在系统回收分配给它的资源之前，该进程短暂地处于这种状态。</dd></dl><h2 id="线程的调用" tabindex="-1"><a class="header-anchor" href="#线程的调用" aria-hidden="true">#</a> 线程的调用</h2><h3 id="线程的优先级-了解、自学" tabindex="-1"><a class="header-anchor" href="#线程的优先级-了解、自学" aria-hidden="true">#</a> 线程的优先级（了解、自学）</h3><p>当一个时刻有多个线程处于可运行状态，它们需要排队等待 CPU 资源，每个线程会自动获得一个线程的优先级<small>（Priority）</small>，优先级的高低反映线程的重要或紧急程序。</p><p>可运行状态<small>（Runnable）</small>的线程按优先级排队，线程调度依据建立在优先级基础上的『先到先服务』原则。</p><blockquote><p>线程的调度是操作系统的重要功能和职责。</p><p>线程调度的规则依赖于操作系统内核的实现。有的操作系统会充分遵守优先级规则，有的系统只是将优先级当做『<strong>建议值</strong>』，而有的操作系统则完全没有优先级概念、无视优先级，完全随机。</p><p><strong>所以不能以优先级作为控制线程先后执行顺序的手段！</strong></p></blockquote><p>线程的优先级用 1 ... 10 表示，10 表示优先级最高，默认值是 5。Thread 类中有对应的静态常量：NORM_PRIORITY、MIN_PRIORITY、MAX_PRIORITY 。</p><p>线程的优先级可以通过 <strong>Thread#setPriority(int level)</strong> 方法更改。</p><h3 id="实现线程调度的方法" tabindex="-1"><a class="header-anchor" href="#实现线程调度的方法" aria-hidden="true">#</a> 实现线程调度的方法</h3><p>线程调度的实现核心思路只有一个：<strong>通过各种手段，迫使一个线程<small>（通常是当前执行线程）</small>让出 CPU ，从而让其它线程拥有执行机会</strong>。</p><ul><li><p>手段一：<strong>Thread#join</strong> 方法</p><p>Thread#join 方法会导致当前线程阻塞<small>（让出 CPU）</small>，等待调用该方法的线程<small>（即，Thread 对象所代表的那个线程）</small>结束后再继续执行本线程。</p></li><li><p>手段二：<strong>Thread.sleep</strong> 方法</p><p>Thread.sleep 方法会导致当前线程睡眠<small>（本质上也是阻塞，迫使当前线程让出 CPU）</small>，在指定时间到期后，重新进入可运行状态。</p></li><li><p>手段三：<strong>Thread.yield</strong> 方法</p><p>Thread.yield 方法稍微有点不同，它让当前线程让出 CPU ，但并不是进入阻塞状态，而是直接进入 Runnable 状态。</p></li></ul><p>需要注意的是，当前线程让出 CPU 之后，接下来是哪个线程执行<small>（从 Runnable 状态变为 Running 状态）</small>带有『<strong>不确定性</strong>』。</p><h3 id="线程的同步与互斥" tabindex="-1"><a class="header-anchor" href="#线程的同步与互斥" aria-hidden="true">#</a> 线程的同步与互斥</h3><p>当两个或多个线程需要访问同一资源<small>（或执行同一段代码时）</small>，需要某一时刻只能被一个线程使用的方式，称为线程『<strong>互斥</strong>』。</p><p>当两个或多个线程以互斥的方式访问完同一资源<small>（或执行同一段代码）</small>后，『通知』其他线程的方式，称为线程『<strong>同步</strong>』。</p><blockquote><p>同步与互斥通常总是一起出现的。只出现互斥，不出现同步，意味着代码逻辑是一种极简单的多线程状况。</p></blockquote><h3 id="synchronized-关键字" tabindex="-1"><a class="header-anchor" href="#synchronized-关键字" aria-hidden="true">#</a> synchronized 关键字</h3><p>使用 <strong>synchronized</strong> 关键字修饰的方法控制对类成员变量的访问。每个类实例都对应一把锁，方法一旦执行，就独占该锁，直到方法结束时才将锁释放；此后其它被阻塞的线程才能获得该锁，重新进入可执行状态。</p><p>这种机制保证了同一时刻，对于每一个实例，其所声明为 synchronized 的方法只能有一个处于可执行状态，从而有效地避免了类成员变量的访问冲突。</p><p>语法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code>访问修饰符 <span class="token keyword">synchronized</span> 返回类型 方法名 <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>或</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">synchronized</span> 访问修饰符 返回类型 方法名 <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>synchronized 方法的缺陷在于：如果将一个耗时的方法声明为 synchronized 将会使其它线程阻塞时间过长，从而影响系统执行效率和用户体验。</p><p>同步代码块是同步方法的缺陷的解决方案，它『锁住』的不是整个方法，而是方法中的一个代码片段。</p><p>语法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>一个对象<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里的『一个对象』通常是一个字符串常量对象。</p><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h2><p>Java 并发 API 对『<strong>锁</strong>』提供了支持。锁是一些对象，它们为 synchronized 提供了替代方案。</p><p><strong>锁<small>（Lock）</small></strong> 不仅能实现 synchronized 的互斥功能，还能进一步实现线程间的同步功能。</p><p>锁的工作原理如下：在访问共享资源之前，申请用于保护资源的锁；当资源访问结束完成时，释放锁。当某个线程正在使用锁时，如果另一个线程尝试申请锁，那么后者将会阻塞等待，直到锁被前者释放位置。</p><blockquote><p>锁的作用，逻辑上，就是一个令牌、通行证。持有这个令牌、通行证的线程才能继续执行。没有这个令牌、通行证的线程，无法继续执行，直到令牌的持有者放下令牌，而被它拿到后，它才能继续执行。</p></blockquote><p>所有的锁都要实现 <strong>Lock</strong> 接口，最常用的 Lock 接口的实现类是 <strong>ReentrantLock</strong> 。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void lock()</td><td>进行等待，直到可以获得锁为止</td></tr><tr><td>void lockInterruptibly() throws ...</td><td>除非被中断，否则进行等待，直到可以获得锁为止</td></tr><tr><td>Condition newCondition()</td><td>返回与调用锁关联的 Condition 对象</td></tr><tr><td>boolean tryLock()</td><td>尝试获得锁，如果锁不可获得，立即返回 false；如果可获得，返回 true</td></tr><tr><td>boolean tryLock(long wait, TimeUnit unit) throws ...</td><td>在指定时间内，尝试获得锁。如果超出时间后仍无法获得，则返回 false；如果可获得，则返回 true</td></tr><tr><td>void unlock()</td><td>释放锁</td></tr></tbody></table><p>ReentrantLock 实现了一种可重入锁，当前持有锁的线程能够重复进入这种锁。当然，对于线程重入锁而言，所有 lock ( ) 调用必须有相同数量的 unlock ( ) 调用进行抵消。</p>',80),e={render:function(t,n){return l}}}}]);