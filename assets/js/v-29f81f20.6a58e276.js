"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[5555],{87543:(n,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t={key:"v-29f81f20",path:"/utility/spring-utils/08-Eventbus.html",title:"Spring 中的 EventBus",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"自定义 Event",slug:"自定义-event",children:[]},{level:2,title:"定义 EventListener",slug:"定义-eventlistener",children:[]},{level:2,title:"触发事件",slug:"触发事件",children:[]}],filePathRelative:"utility/spring-utils/08-Eventbus.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},75085:(n,s,a)=>{a.r(s),a.d(s,{default:()=>e});const t=(0,a(66252).uE)('<h1 id="spring-中的-eventbus" tabindex="-1"><a class="header-anchor" href="#spring-中的-eventbus" aria-hidden="true">#</a> Spring 中的 EventBus</h1><p>如果你不想或不能引入 EventBus 包，甚至项目中也没有使用 Guava 包，而你又想使用 EventBus 功能，那么你可以直接使用 Spring 中的 EventBus 。</p><p>不过 Spring 的 EventBus 没有 EventBus 包和 Guava 包那么方便，使用的时候有一些『条条框框』必须遵守。</p><p>Spring 的事件监听有三个部分组成：</p><table><thead><tr><th style="text-align:center;">#</th><th style="text-align:left;">说明</th><th style="text-align:left;">类/方法</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:left;">监听器</td><td style="text-align:left;">ApplicationListener 类</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:left;">事件</td><td style="text-align:left;">ApplicationEvent 类</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:left;">事件发布</td><td style="text-align:left;">publishEvent 方法</td></tr></tbody></table><h2 id="自定义-event" tabindex="-1"><a class="header-anchor" href="#自定义-event" aria-hidden="true">#</a> 自定义 Event</h2><p>自定义的 Event 类的对象在这里起到 2 个作用：</p><ol><li>它本质上是参数对象；</li><li>Spring 用它（的类型）对应到了一个执行具体逻辑代码的处理类。</li></ol><p>简而言之，Spring 未来会去调用这个真正有价值的处理类（的一个方法），然后将我们自定义的 Event 传给它的方法作为参数。</p><p>Spring 的 EventBus 要求事件对象<small>（Event）</small>必须继承 Spring 的 <strong>ApplicationEvent</strong> 类，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XxxEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">public</span> <span class="token class-name">XxxEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">//      System.out.println(&quot;source message-&gt;&quot; + source.toString());</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面的那个 <strong>source</strong> 属性就是我们必须要遵守的『条条框框』之一。</p><p>由于我们自定义的 XxxEvent 必须继承自 <strong>ApplicationEvent</strong> ，所以，XxxEvent 从它的老祖宗们那里继承下来了一个 <code>Object source</code> 属性。</p><p>这个 <strong>source</strong> 属性用作何用、用在何处，Spring EventBus 完全不管。但是通过继承，EventBus 变相强制性地要求你的 XxxEvent 中必须有这么个属性，而且我们必须实现的有参构造必须对它赋值，哪怕你初始化为 null 都行，但是也必须对 <strong>source</strong> 进行初始化。</p><p>除了必要的 <strong>source</strong> 之外，你可以添加更多的属性，例如：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAddedEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span> <span class="token punctuation">{</span>\n    <span class="token keyword">private</span> <span class="token class-name">String</span> xxx<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">Integer</span> yyy<span class="token punctuation">;</span>\n    <span class="token keyword">private</span> <span class="token class-name">Date</span> zzz<span class="token punctuation">;</span>\n\n    <span class="token doc-comment comment">/**\n     * 加上从老祖宗那里继承来的 source，这个 Event 中总共是 4 个属性。\n     */</span>\n    <span class="token keyword">public</span> <span class="token class-name">UserAddedEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">,</span> <span class="token class-name">String</span> xxx<span class="token punctuation">,</span> <span class="token class-name">Integer</span> yyy<span class="token punctuation">,</span> <span class="token class-name">Date</span> zzz<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>xxx <span class="token operator">=</span> xxx<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>yyy <span class="token operator">=</span> yyy<span class="token punctuation">;</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>zzz <span class="token operator">=</span> zzz<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这些属性（加上默认的 <code>Object source</code>）就是未来事件发送方需要『传递』给事件接收方的数据。</p><p><strong>注意</strong>：考虑到可以有多个事件的监听者，为了避免这些数据的无意中的篡改，这些属性最好是 final 的，或者只提供 getter，不提供 setter 。</p><h2 id="定义-eventlistener" tabindex="-1"><a class="header-anchor" href="#定义-eventlistener" aria-hidden="true">#</a> 定义 EventListener</h2><p>有 2 种方式创建事件监听器：</p><ul><li><p>使用 <strong>@EventListener</strong> 注解</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAddedEventListener2</span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@EventListener</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">UserAddedEvent</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">UserAddedEvent</span> userAddedEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;收到了 UserAdded 事件&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userAddedEvent<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li><li><p>实现 <strong>ApplicationListener</strong> 接口：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAddedEventListener1</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserAddedEvent</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">UserAddedEvent</span> userAddedEvent<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;收到了 UserAdded 事件1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userAddedEvent<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ul><p>可以有多个监听器监听同一个事件。</p><p><strong>注意</strong>：EventHandler 对象需要托管给 Spring IoC 容器。</p><h2 id="触发事件" tabindex="-1"><a class="header-anchor" href="#触发事件" aria-hidden="true">#</a> 触发事件</h2><p>通过 Spring 的 Context 对象就能发出事件，触发事件处理程序的执行。</p><p>其实真正『对口』的是 <strong>ApplicationEventPublisher</strong> 接口，而各种 ApplicationContext 都直接或间接实现了这个接口。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">AnnotationConfigApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token class-name">MyApplicationContext</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\ncontext<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">XxxEvent</span><span class="token punctuation">(</span><span class="token string">&quot;tom&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>发布事件之后，监听器中的方法会被触发执行。这里本质上还是『<strong>同步调用</strong>』，发布方、监听器1、监听器2 ... 监听器N 仍然在同一个线程中执行。</p>',28),e={render:function(n,s){return t}}}}]);