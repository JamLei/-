"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[1035],{93380:(t,e,l)=>{l.r(e),l.d(e,{data:()=>d});const d={key:"v-5b61d7fa",path:"/java8/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",title:"线程池",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"线程池的创建",slug:"线程池的创建",children:[]},{level:2,title:"线程池的状态",slug:"线程池的状态",children:[]},{level:2,title:"相关 API",slug:"相关-api",children:[]}],filePathRelative:"java8/线程池.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},51802:(t,e,l)=>{l.r(e),l.d(e,{default:()=>i});const d=(0,l(66252).uE)('<h1 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池" aria-hidden="true">#</a> 线程池</h1><p>线程池的好处：</p><ul><li><p>重用存在的线程，减少对象的创建/销毁的开销，性能更佳。</p></li><li><p>可有效控制最大并发线程数量，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞。</p></li><li><p>提供定时执行、定期执行、单线程、并发数控制等功能。</p></li></ul><p><strong>ThreadPoolExecutor</strong> 是 J.U.C 中提供的线程池类。</p><h2 id="线程池的创建" tabindex="-1"><a class="header-anchor" href="#线程池的创建" aria-hidden="true">#</a> 线程池的创建</h2><p>创建线程池时（<em><code>new ThreadPoolExecutor()</code></em>）会涉及到如下几个参数：</p><ul><li><p>corePoolSize：线程池的核心线程数量。逻辑上，就是线程池中线程数量的下限。</p></li><li><p>maximumPoolSize：线程池最大线程数。逻辑上，就是线程池中线程数量的上限。</p></li><li><p>poolSize：线程池当前的线程数。它的值会在 corePoolSize 和 maximumPoolSize 之间。</p></li><li><p>workQueue：阻塞队列，存储待执行的任务。很重要，会对线程池运行过程产生重大影响。</p></li><li><p>keepAliveTime：线程没有任务执行时最多保持多久时间终止。</p></li><li><p>unit：keepAliveTime 的时间单位</p></li><li><p>threadFactory：线程工厂，用来创建线程</p></li><li><p>rejectHandler：当拒绝处理任务（例如线程池已满，不再接受新任务）时的策略</p></li></ul><p>不过通常我们并非使用 new 的方式创建线程池。J.U.C 提供了 <strong><code>Executors</code></strong> 工具类，并提供了几个简化线程池创建的方法：</p><ul><li><p><code>Executors.newSingleThreadExecutor()</code></p><p>创建一个单线程的线程池。该线程池中有且仅有一个工作线程（来处理任务），即，线程池中储于 Running 状态的线程数不能超过 1 。</p><p>当任务数超过 1 时，需要等待。</p></li><li><p><code>Executors.newFixThreadPool()</code></p><p>创建一个线程数目固定的线程池。对于添加到任务队列中的任务，如果线程池还有可用线程，那么就执行该任务。如果所有线程已被占用，那么任务的执行将会等到有线程执行完它手头的工作（任务）后才开始。</p></li><li><p><code>Executors.newScheduledThreadPool()</code></p><p>同上。还支持定时及周期性任务执行。</p></li><li><p><code>Executors.newCachedThreadPool()</code></p><p>创建一个可缓存线程。逻辑上就是 FixThreadPool 的【反面】。</p><p>该线程池一旦发现线程不够用就会创建新线程去执行新添加的任务，并且它会复用已有的线程。线程执行完任务后，如果存活期到期，到期时间内一直未被使用，那么线程池会销毁过期的线程。</p></li></ul><h2 id="线程池的状态" tabindex="-1"><a class="header-anchor" href="#线程池的状态" aria-hidden="true">#</a> 线程池的状态</h2><table><thead><tr><th style="text-align:left;">状态</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">Running</td><td style="text-align:left;">线程池正在运行中</td></tr><tr><td style="text-align:left;">Shutdown</td><td style="text-align:left;">关闭状态之一。这种状态下线程池不再接受新的任务，但是会将已接受的任务处理完。处理完后，线程池会自动进入 Tidying 状态。</td></tr><tr><td style="text-align:left;">Stop</td><td style="text-align:left;">另一种关闭状态。这种状态下不再接受新的任务，并且会放弃已接受的而又未执行的任务。不仅如此，它还会取消正在执行中的任务。取消掉正在执行的任务后，线程池会自动进入 Tidying 状态。</td></tr><tr><td style="text-align:left;">Tidying</td><td style="text-align:left;">这种状态下的线程池意味着不再具有任何功能。其中工作线程数量为 0 。</td></tr><tr><td style="text-align:left;">Terminated</td><td style="text-align:left;">这种状态下线程池彻底停止，接下来就是 JVM 着手回收相关对象。</td></tr></tbody></table><h2 id="相关-api" tabindex="-1"><a class="header-anchor" href="#相关-api" aria-hidden="true">#</a> 相关 API</h2><table><thead><tr><th style="text-align:left;">方法</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><code>execute()</code></td><td style="text-align:left;">提交任务，交给线程池执行。</td></tr><tr><td style="text-align:left;"><code>submit()</code></td><td style="text-align:left;">同上。能够返回执行结果。结合 Callable 和 Future 使用。</td></tr><tr><td style="text-align:left;"><code>shutdown()</code></td><td style="text-align:left;">关闭线程池，等待任务都执行完。即，线程池进入 Shutdown 状态。</td></tr><tr><td style="text-align:left;"><code>shutdownNow()</code></td><td style="text-align:left;">关闭线程池，不等待任务执行完。即，线程池进入 Stop 状态。</td></tr><tr><td style="text-align:left;"><code>getTaskCount()</code></td><td style="text-align:left;">返回线程池已执行和未执行任务总数。即，总共接收的任务数。</td></tr><tr><td style="text-align:left;"><code>getCompletedTaskCount()</code></td><td style="text-align:left;">返回线程中已完成的任务数。</td></tr><tr><td style="text-align:left;"><code>getPoolSize()</code></td><td style="text-align:left;">返回线程池当前的线程数量。</td></tr><tr><td style="text-align:left;"><code>getActiveCount()</code></td><td style="text-align:left;">返回线程池中正在执行任务的线程数量。</td></tr></tbody></table>',13),i={render:function(t,e){return d}}}}]);