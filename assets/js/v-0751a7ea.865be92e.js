"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[448],{8018:(e,s,a)=>{a.r(s),a.d(s,{data:()=>n});const n={key:"v-0751a7ea",path:"/docker/03-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4.html",title:"Docker 常用命令",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"列出镜像",slug:"列出镜像",children:[]},{level:2,title:"搜索镜像",slug:"搜索镜像",children:[]},{level:2,title:"拉取镜像",slug:"拉取镜像",children:[]},{level:2,title:"删除镜像",slug:"删除镜像",children:[]},{level:2,title:"创建并启动容器",slug:"创建并启动容器",children:[]},{level:2,title:"列出容器",slug:"列出容器",children:[]},{level:2,title:"执行命令",slug:"执行命令",children:[]},{level:2,title:"停止容器",slug:"停止容器",children:[]},{level:2,title:"启动容器",slug:"启动容器",children:[]},{level:2,title:"10. 删除容器",slug:"_10-删除容器",children:[]},{level:2,title:"11. 构建镜像（自学、了解）",slug:"_11-构建镜像-自学、了解",children:[]},{level:2,title:"12. 文件拷贝",slug:"_12-文件拷贝",children:[]},{level:2,title:"13. 目录挂载",slug:"_13-目录挂载",children:[]},{level:2,title:"14. 查看容器 IP 地址",slug:"_14-查看容器-ip-地址",children:[]},{level:2,title:"15. 查看运行日志",slug:"_15-查看运行日志",children:[]}],filePathRelative:"docker/03-常用操作命令.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},93077:(e,s,a)=>{a.r(s),a.d(s,{default:()=>t});const n=(0,a(66252).uE)('<h1 id="docker-常用命令" tabindex="-1"><a class="header-anchor" href="#docker-常用命令" aria-hidden="true">#</a> Docker 常用命令</h1><p>在使用 Docker 时，经常会操作镜像与容器，这就会涉及各种操作指令的使用。</p><table><thead><tr><th style="text-align:left;">指令</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">docker images</td><td style="text-align:left;">列出镜像</td></tr><tr><td style="text-align:left;">docker search</td><td style="text-align:left;">搜索镜像</td></tr><tr><td style="text-align:left;">docker pull</td><td style="text-align:left;">拉取镜像</td></tr><tr><td style="text-align:left;">docker rmi</td><td style="text-align:left;">删除镜像</td></tr><tr><td style="text-align:left;">docker run</td><td style="text-align:left;">创建并启动容器</td></tr><tr><td style="text-align:left;">docker ps</td><td style="text-align:left;">列出容器</td></tr><tr><td style="text-align:left;">docker exec</td><td style="text-align:left;">执行容器</td></tr><tr><td style="text-align:left;">docker stop</td><td style="text-align:left;">停止容器</td></tr><tr><td style="text-align:left;">docker start</td><td style="text-align:left;">启动容器</td></tr><tr><td style="text-align:left;">docker rm</td><td style="text-align:left;">删除容器</td></tr><tr><td style="text-align:left;">docker build</td><td style="text-align:left;">构建镜像</td></tr></tbody></table><h2 id="列出镜像" tabindex="-1"><a class="header-anchor" href="#列出镜像" aria-hidden="true">#</a> 列出镜像</h2><p>通过 <strong>docker images</strong> 指令可以查看本地镜像列表中已有的镜像：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker images\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>它所返回的镜像列表信息包含了一下 5 个字段：</p><table><thead><tr><th style="text-align:right;">字段名</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:right;">REPOSITORY</td><td style="text-align:left;">镜像的名称。会一并显示它的 Namespace</td></tr><tr><td style="text-align:right;">TAG</td><td style="text-align:left;">镜像的标签</td></tr><tr><td style="text-align:right;">IMAGE ID</td><td style="text-align:left;">镜像的 ID。一个长 64 位的十六进制字符串（SHA256 算法的运算结果）</td></tr><tr><td style="text-align:right;">CREATE</td><td style="text-align:left;">镜像的创建时间</td></tr><tr><td style="text-align:right;">SIZE</td><td style="text-align:left;">镜像所占用的硬盘空间（包括被共享的镜像层的大小）</td></tr></tbody></table><p>当本地镜像较多时，还可以使用通配符过滤出符合条件的镜像。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">sudo</span> docker images ph*\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="搜索镜像" tabindex="-1"><a class="header-anchor" href="#搜索镜像" aria-hidden="true">#</a> 搜索镜像</h2><p>想知道在 Docker Hub 中包含了哪些镜像，除了可以登录 Docker Hub，在官网搜索外，还可以直接通过 Docker 命令 <strong>docker search</strong> 进行搜索。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker search mysql\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>显示出来的搜索结果中包含了镜像的如下信息：</p><table><thead><tr><th style="text-align:right;">字段名</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:right;">NAME</td><td style="text-align:left;">镜像的名称</td></tr><tr><td style="text-align:right;">DESCRIPTION</td><td style="text-align:left;">镜像的简单描述</td></tr><tr><td style="text-align:right;">STARTS</td><td style="text-align:left;">镜像在的点赞数</td></tr><tr><td style="text-align:right;">OFFICIAL</td><td style="text-align:left;">镜像是否为 Docker 官方提供<small>（建议使用官方提供的镜像）</small></td></tr><tr><td style="text-align:right;">AUTOMATED</td><td style="text-align:left;">镜像是否使用了自动构建</td></tr></tbody></table><h2 id="拉取镜像" tabindex="-1"><a class="header-anchor" href="#拉取镜像" aria-hidden="true">#</a> 拉取镜像</h2><p>通过 <strong>docker pull</strong> 指令可以拉取仓库镜像到本地<small>（默认都是拉取 Docker Hub 仓库镜像）。</small></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker pull ubuntu\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Docker 会利用镜像的分层机制，将镜像分为多个包进行下载，我们可以在终端输出中看到每层的下载状态。</p><div class="custom-container warning"><p class="custom-container-title">WARNING</p><ul><li><p>按照镜像的命名规则（<code>Namespace/Repository:Tag</code> ），上例中的 ubuntu 就是一个镜像的 Repository 名。</p></li><li><p>没有指明 Namespace，就表示 Docker 官方管理的镜像。</p></li><li><p>没有指明 Tag，Docker 默认会使用 <code>latest</code> 标签，表示最新版本。</p></li><li><p>通常情况下，还是倾向于提供更确定的镜像信息，以减少镜像版本带来的不确定性。</p></li></ul></div><h2 id="删除镜像" tabindex="-1"><a class="header-anchor" href="#删除镜像" aria-hidden="true">#</a> 删除镜像</h2><p>当本地存放过多不需要的镜像时，可以通过 <strong>docker rmi</strong> 指令将其删除。在删除镜像时，需要指定镜像名称或镜像 ID 。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker rmi -f <span class="token operator">&lt;</span>image_name or image_id<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>默认情况下，<strong>如果至少还存在一个容器使用该镜像，那么该镜像无法删除</strong>。</p><p><strong>-f</strong> 选项表示停止容器，并强制删除该镜像。不过并不推荐强制删除。</p><p>如果一个镜像中含有某些与其它镜像共享的镜像层，这些被共享的镜像层仍会被保留下来，</p><p>只有未被其它镜像使用的层会被删除。</p><p>我们同样可以指定镜像 ID 删除镜像：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker rmi 4e38e38c8ce0\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="创建并启动容器" tabindex="-1"><a class="header-anchor" href="#创建并启动容器" aria-hidden="true">#</a> 创建并启动容器</h2><p>Docker 镜像主要用于创建容器，可以使用 <strong>docker run</strong> 指令创建并启动容器。例如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run -d -p <span class="token number">5000</span>:80 --name <span class="token builtin class-name">test</span> hello-world\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul><li><p>命令说明： <strong>docker run</strong></p><p>表示创建并启动一个容器。最后的 hello-word 表示制作该容器的。</p></li><li><p>命令说明： <strong>-d</strong></p><p>表示容器启动后在后台运行</p></li><li><p>命令说明： <strong>-p 5000:80</strong></p><p>表示将主机的 5000 端口和容器的 80 端口『对接』。即，宿主机从 5000 端口收到的数据，由系统送到 docker 的 80 端口。</p></li><li><p>命令说明： <strong>--name test</strong></p><p>表示所创建的容器的名字为 test 。</p></li><li><p>命令说明： <strong>hello-world</strong></p><p>表示以 <code>hello-world</code> 镜像为基础创建容器。</p></li></ul><p>需要注意的是：</p><ul><li><p><strong>docker run</strong> 命令包含了两个动作：<strong>创建容器</strong> 和 <strong>启动容器</strong> 。</p></li><li><p>镜像和容器是一对多的关系：同一个镜像可以用来制作多个容器。</p></li></ul><p>Docker 容器有以下两种运行态：</p><ul><li><p>前台交互式</p><ul><li><p>容器运行在前台，容器运行时直接连接到容器中运行的程序上。</p></li><li><p>这种场景下，我们通常会通过附加的参数打开容器的伪终端和输入流，从而实现与容器中程序的交互。</p></li><li><p>当通过命令退出和关闭链接时，容器即停止运行。</p></li><li><p><code>sudo docker run -i -t ubuntu /bin/bash</code></p><ul><li><p><strong>-i</strong> 表示开启了 input（输入）功能</p></li><li><p><strong>-t</strong> 表示开启了一个连接容器里边的 terminal（终端）</p></li><li><p><strong>-it</strong> 常一起使用</p></li></ul></li></ul></li><li><p>后台守护式</p><ul><li><p>容器运行在后台，运行的过程中不会占用当前输入指定的终端，也不会连接到容器内的程序上。</p></li><li><p>这种运行后台容器必须通过指令来关闭<small>（<code>docker stop</code>）</small>。</p></li><li><p><code>sudo docker run -d nginx</code></p></li></ul></li></ul><h2 id="列出容器" tabindex="-1"><a class="header-anchor" href="#列出容器" aria-hidden="true">#</a> 列出容器</h2><p>生成容器后，可以通过 <strong>docker ps</strong> 指令查看当前运行的所有容器：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token function">ps</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><table><thead><tr><th style="text-align:right;">字段名</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:right;">CONTAINER ID</td><td style="text-align:left;">容器的唯一性标识</td></tr><tr><td style="text-align:right;">IMAGE</td><td style="text-align:left;">容器所使用的镜像</td></tr><tr><td style="text-align:right;">COMMAND</td><td style="text-align:left;">容器启动时运行的命令<small>（即，容器中的主程序）</small></td></tr><tr><td style="text-align:right;">CREATED</td><td style="text-align:left;">容器的创建时间</td></tr><tr><td style="text-align:right;">STATUS</td><td style="text-align:left;">容器的运行状态。<small>Up 表示运行中，Exited 标识已停止</small></td></tr><tr><td style="text-align:right;">PORTS</td><td style="text-align:left;">容器内部包括的端口映射到的主机端口</td></tr><tr><td style="text-align:right;">NAMES</td><td style="text-align:left;">容器的名称</td></tr></tbody></table><ul><li><p>参数 <strong>-a</strong></p><p>使用 <strong>docker ps</strong> 命令只会列出正在运行中的程序，如果要列出所有容器，需要携带参数 <strong>-a</strong> 。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">sudo</span> docker <span class="token function">ps</span> -a\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>参数 <strong>-l</strong></p><p>当我们创建了较多容器时<small>（使用 <strong>docker ps</strong> 命令返回结果过多）</small>，可以使用 <strong>-l</strong> 参数列出最后创建的那个容器：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">sudo</span> docker <span class="token function">ps</span> -l\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>参数 <strong>-n</strong></p><p>也可以使用 <strong>-n</strong> 参数可以列出数个最近创建的容器：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">sudo</span> docker <span class="token function">ps</span> -n <span class="token number">2</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul><h2 id="执行命令" tabindex="-1"><a class="header-anchor" href="#执行命令" aria-hidden="true">#</a> 执行命令</h2><p>当生成容器后，客户端可以通过 <strong>docker exec</strong> 指令与运行中的容器进行通信，在通信时需要指定容器的 ID 或 Name 。</p><ul><li><p>例如，让容器去执行 <em>ls -l</em> 。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token builtin class-name">exec</span> f0c9a8b6e8c5 <span class="token function">ls</span> -l\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul><h2 id="停止容器" tabindex="-1"><a class="header-anchor" href="#停止容器" aria-hidden="true">#</a> 停止容器</h2><p>当不需要容器运行时，可以使用 <strong>docker stop</strong> 指令停止指定的容器。</p><ul><li><p>语法：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker stop <span class="token operator">&lt;</span>container_name or container_id<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul><p>使用上述指令停止容器时会略有延迟，成功后返回该容器的 ID 。</p><p>另外，<strong>docker ps</strong> 命令的执行结果中不会显示已停止的容器，如需查看这些容器要使用 <strong>-a</strong> 选项。</p><p>我们还可以通过 <strong>docker kill</strong> 指令立即杀死运行容器进程。</p><ul><li><p>语法：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token function">kill</span> <span class="token operator">&lt;</span>container_name or container_id<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul><h2 id="启动容器" tabindex="-1"><a class="header-anchor" href="#启动容器" aria-hidden="true">#</a> 启动容器</h2><p>容器停止后，如果需要重新访问该容器中的程序，需要重新启动该容器：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker start <span class="token operator">&lt;</span>container_id or container_name<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>除了 <strong>docker start</strong> 指令可以启动已停止的容器外，还可以使用 <strong>docker restart</strong> 指令重启容器。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker restart <span class="token operator">&lt;</span>container_id or container_name<span class="token operator">&gt;</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="_10-删除容器" tabindex="-1"><a class="header-anchor" href="#_10-删除容器" aria-hidden="true">#</a> 10. 删除容器</h2><p>当不需要使用容器时，则可以使用 <strong>docker rm</strong> 指令删除已停止的容器：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token function">rm</span> <span class="token operator">&lt;</span>container_id or container_name<span class="token operator">&gt;</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>默认情况下，上述指令『<strong>只能删除已停止的容器</strong>』。如需要删除正在运行的容器，则需要添加 <strong>-f</strong> 参数强制删除。</p><p><strong>docker rm</strong> 指令可以传入多个容器的 ID 或名字进行批量删除，甚至可以套用 <strong>docker ps</strong> 命令全部删除：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>在这里，我们借助 <strong>docker ps -aq</strong> 指令去求得所有容器的 ID 。</p><p>因为 Docker 特有的镜像机制，在创建容器过程中并没有大量的 IO 操作，所以创建过程是秒级的。因此，我们更倾向于『<strong>随用随建，随停随删</strong>』。在停止程序所在容器时，将容器一并删除。</p><h2 id="_11-构建镜像-自学、了解" tabindex="-1"><a class="header-anchor" href="#_11-构建镜像-自学、了解" aria-hidden="true">#</a> 11. 构建镜像（自学、了解）</h2><p>除了可以通过 <strong>docker pull</strong> 指令从仓库拉取镜像之外，还可以通过 <strong>docker build</strong> 指令构建 Docker 镜像。</p><ul><li><p>有两种方式进行镜像构建：</p><ol><li><p>进入 Dockerfile 文件所在目录后，可以使用 <strong>docker build</strong> 指令进行镜像构建。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>cd ~/workspace/dockerspace/\ndocker build -t hellodocker .\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上述的 <code>.</code> 表示通过当前目录下的 Dockerfile 文件进行镜像构建。</p></li><li><p>在其他任意目录进行镜像构建</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker build -t hellodocker ~/workspace/dockerspace/\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>通过同一个 Dockerfile 构建出来的镜像 ID 会相同。</p></li></ol></li></ul><h2 id="_12-文件拷贝" tabindex="-1"><a class="header-anchor" href="#_12-文件拷贝" aria-hidden="true">#</a> 12. 文件拷贝</h2><p>如果我们需要将文件拷贝到容器内可以使用 <strong>docker cp</strong> 命令</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token function">cp</span> <span class="token operator">&lt;</span>主机中的文件路径名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>容器名<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>容器中的目录<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>例如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token function">cp</span> /tmp/1.txt microboom:/tmp/1.txt\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>也可以反向将文件从容器内拷贝出来：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token function">cp</span> <span class="token operator">&lt;</span>容器名<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>容器中的文件路径名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>主机中的文件路径名<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="_13-目录挂载" tabindex="-1"><a class="header-anchor" href="#_13-目录挂载" aria-hidden="true">#</a> 13. 目录挂载</h2><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样容器中的某个目录和真机中的某个目录是同一个目录，容器和真机就可以以此为桥梁相互影响。</p><p>例如，我们可以创建一个运行 mysql 的容器，将容器中存放数据文件的目录映射到真机中的某个目录。这样，哪怕是该容器被删除了，曾经存储的数据仍然还在。</p><ul><li><p>语法：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run <span class="token punctuation">..</span>. -v 宿主机目录:容器目录\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul><p>例如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run                    <span class="token punctuation">\\</span>\n  -d                          <span class="token punctuation">\\</span>\n  --rm                        <span class="token punctuation">\\</span>\n  -v /home/ben/mysql/conf:/etc/mysql/conf.d   <span class="token punctuation">\\</span>\n  -v /home/ben/mysql/data:/var/lib/mysql      <span class="token punctuation">\\</span>\n  -p <span class="token number">3306</span>:3306                <span class="token punctuation">\\</span>\n  -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123</span>  <span class="token punctuation">\\</span>\n  --name mysql                <span class="token punctuation">\\</span>\n  mysql:5.7.22\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_14-查看容器-ip-地址" tabindex="-1"><a class="header-anchor" href="#_14-查看容器-ip-地址" aria-hidden="true">#</a> 14. 查看容器 IP 地址</h2><p>我们可以通过以下命令查看容器运行的各种数据：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker inspect <span class="token operator">&lt;</span>container_name_or_id<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>当然，从中查找容器的 IP 地址很不方便，因此，可以对此再细化一下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker inspect --format<span class="token operator">=</span><span class="token string">&#39;\\{\\{.NetworkSettings.IPAddress}}&#39;</span> <span class="token operator">&lt;</span>container_name_or_id<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>补，去掉上述命令中的两个 <code>\\</code> 。</p><h2 id="_15-查看运行日志" tabindex="-1"><a class="header-anchor" href="#_15-查看运行日志" aria-hidden="true">#</a> 15. 查看运行日志</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker logs -f --tail<span class="token operator">=</span><span class="token number">100</span> 容器名称\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>『完』</p>',90),t={render:function(e,s){return n}}}}]);