"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[9533],{16829:(e,i,l)=>{l.r(i),l.d(i,{data:()=>s});const s={key:"v-6424a2e0",path:"/redis/04-%E9%9B%86%E7%BE%A4-1.html",title:"Redis 集群（1）",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"Redis 主从复制",slug:"redis-主从复制",children:[]},{level:2,title:"Redis Sentinel（哨兵）模式",slug:"redis-sentinel-哨兵-模式",children:[]}],filePathRelative:"redis/04-集群-1.md",git:{updatedTime:1629826614e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},96723:(e,i,l)=>{l.r(i),l.d(i,{default:()=>t});const s=(0,l(66252).uE)('<h1 id="redis-集群-1" tabindex="-1"><a class="header-anchor" href="#redis-集群-1" aria-hidden="true">#</a> Redis 集群（1）</h1><p>Redis 集群是一个提供在多个 Redis 间节点间共享数据的程序集。</p><blockquote><p>Redis 集群并不支持处理多个 keys 的命令，因为这需要在不同的节点间移动数据，从而达不到像 Redis 那样的性能，在高负载的情况下可能会导致不可预料的错误。</p></blockquote><p>Redis 集群通过分区来提供一定程度的可用性，在实际环境中『<strong>当某个节点宕机或者不可达的情况下继续处理命令</strong>』，Redis 集群的优势：</p><ul><li><p>自动分割数据到不同的节点上。</p></li><li><p>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</p></li></ul><h2 id="redis-主从复制" tabindex="-1"><a class="header-anchor" href="#redis-主从复制" aria-hidden="true">#</a> Redis 主从复制</h2><p>主从复制的简单流程介绍：</p><ul><li><p>Master 可以拥有多个 slave 。</p></li><li><p>多个 slave 可以连接同一个 Master 外，还可以连接到其他的 slave 。</p></li><li><p>主从复制不会阻塞 Master 在主从复制时，Master 可以处理 client 请求。</p></li><li><p>提供系统的伸缩性。</p></li></ul><p>主从复制简单原理的过程：</p><ol><li><p>slave 与 Master 建立连接，发送 sync 同步命令。 也就是说当用户在 Master 写入一条命令后，他们之间会通过一些算法把数据同步到每一个 slave 上。</p></li><li><p>Msater 会开启一个后台进程，将数据库快照保存到文件中。同时 Master 主进程会开始收集新的写命令并缓存。</p></li><li><p>后台完成保存后，就将文件发送给 slave 。</p></li><li><p>slave 将此文件保存在硬盘上。</p></li></ol><h2 id="redis-sentinel-哨兵-模式" tabindex="-1"><a class="header-anchor" href="#redis-sentinel-哨兵-模式" aria-hidden="true">#</a> Redis Sentinel（哨兵）模式</h2><pre><code>Sentinel [ˈsentɪnl] \n</code></pre><p>Sentinel 工作方式：</p><ul><li><p>每个 Sentinel 以每秒钟一次的频率向它所知的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。</p></li><li><p>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 <em>down-after-milliseconds</em> 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。</p></li><li><p>如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态。</p></li><li><p>当有足够数量的 Sentinel<small>（大于等于配置文件指定的值）</small>在指定的时间范围内确认 Master 的确进入了主观下线状态， 则 Master 会被标记为客观下线。</p></li><li><p>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令。</p></li><li><p>当 Master 被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p></li><li><p>若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。</p></li><li><p>若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</p></li></ul><p><img src="https://hemiao3000.gitee.io/java-note-img/images/redis/img/redis-cluster-01.png" alt="redis-cluster-01"></p>',15),t={render:function(e,i){return s}}}}]);