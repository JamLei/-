"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[5503],{58685:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-7cf19b48",path:"/nginx/02-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html",title:"Nginx 实现负载均衡",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"负载均衡的配置",slug:"负载均衡的配置",children:[]},{level:2,title:"准备工作",slug:"准备工作",children:[]},{level:2,title:"负载：轮循",slug:"负载-轮循",children:[]},{level:2,title:"负载：加权轮循",slug:"负载-加权轮循",children:[]},{level:2,title:"负载：ip_hash 负载",slug:"负载-ip-hash-负载",children:[]},{level:2,title:"将客户端浏览器的 IP 传递到后台",slug:"将客户端浏览器的-ip-传递到后台",children:[]}],filePathRelative:"nginx/02-负载均衡.md",git:{updatedTime:null,contributors:[]}}},64772:(n,s,a)=>{a.r(s),a.d(s,{default:()=>t});const e=(0,a(66252).uE)('<h1 id="nginx-实现负载均衡" tabindex="-1"><a class="header-anchor" href="#nginx-实现负载均衡" aria-hidden="true">#</a> Nginx 实现负载均衡</h1><p>负载均衡<small>（load balance）</small>就是将负载分摊到多个操作单元上执行，从而提高服务的可用性和响应速度，带给用户更好的体验。</p><h2 id="负载均衡的配置" tabindex="-1"><a class="header-anchor" href="#负载均衡的配置" aria-hidden="true">#</a> 负载均衡的配置</h2><p>通过 Nginx 中的 <strong>upstream</strong> 指令可以实现负载均衡，再该指令中能够配置负载均衡服务器组。</p><p>目前负载均衡有 4 种典型的配置方式。分别是：</p><table><thead><tr><th style="text-align:center;">#</th><th style="text-align:left;">负载均衡方式</th><th style="text-align:left;">特点</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:left;">轮询方式</td><td style="text-align:left;">默认方式。每个请求按照时间顺序逐一分配到不同的后端服务器进行处理。如果有服务器宕机，会自动删除。</td></tr><tr><td style="text-align:center;">2</td><td style="text-align:left;">权重方式</td><td style="text-align:left;">利用 weight 指定轮循的权重比率，与访问率成正比。用于后端服务器性能不均衡的情况。</td></tr><tr><td style="text-align:center;">3</td><td style="text-align:left;">ip_hash 方法</td><td style="text-align:left;">每个请求俺早访问 IP 的 hash 结果分配，这样可以使每个方可固定一个后端服务器，可以解决 Session 共享问题。</td></tr><tr><td style="text-align:center;">4</td><td style="text-align:left;">第三方模块</td><td style="text-align:left;">取决于所采用的第三方模块的分配规则。</td></tr></tbody></table><p>在 upstream 指定的服务器组中，若每个服务器的权重都设置为 1<small>（默认值）</small>时，表示当前的负载均衡是一般轮循方式。</p><h2 id="准备工作" tabindex="-1"><a class="header-anchor" href="#准备工作" aria-hidden="true">#</a> 准备工作</h2><p>编写后台<small>（SpringBoot）</small>项目，简单起见，以占用不同的端口的形式启动 2 次，并在返回的信息中返回各自所占用的端口号。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">&quot;${server.port}&quot;</span><span class="token punctuation">)</span>\n<span class="token class-name">String</span> port<span class="token punctuation">;</span>\n\n<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/api/hello&quot;</span><span class="token punctuation">)</span>\n<span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;code&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;10086&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;msg&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;success&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;data&quot;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> map<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="负载-轮循" tabindex="-1"><a class="header-anchor" href="#负载-轮循" aria-hidden="true">#</a> 负载：轮循</h2><p>轮循方式的关键配置如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>server {\n    ...\n    location /api {\n        proxy_pass http://xxx/api;\n        ...\n    }\n}\n\nupstream xxx {\n    server 127.0.0.1:8080;\n    server 127.0.0.1:9090;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上述的配置中有 2 点需要注意的：</p><ol><li><strong>upstream</strong> 配置项在 <strong>http</strong> 配置项内，但是在 <strong>server</strong> 配置项外，它们 3 者整体结构如下<small>（不要写错地方了）</small>：</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>http {\n    # 它们两者平级\n    server { ... }\n    upstream { ...}\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li>你所配置的 <strong>upstream</strong> 的 name 是自定义的，但是不要出现 <strong><code>-</code></strong> 号，否则会和 tomcat 有冲突。</li></ol><p>你持续访问 <code>http://127.0.0.1/api/hello</code> 你会发现页面的内容会是交替出现 <code>8080</code> 端口和 <code>9090</code> 端口。</p><h2 id="负载-加权轮循" tabindex="-1"><a class="header-anchor" href="#负载-加权轮循" aria-hidden="true">#</a> 负载：加权轮循</h2><p>加权轮循就是在轮循的基础上，为每个单点加上权值。权值越重的单点，承担的访问量自然也就越大。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>upstream xxx {\n    server 127.0.0.1:8080 weight=1;\n    server 127.0.0.1:9090 weight=2;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>按照上述配置，<code>9090</code> 端口的服务将承担 2/3 的访问量，而 <code>8080</code> 端口则承担 1/3 的访问量。</p><p>将配置改为上述样子并重启 Nginx 后，再持续访问 <code>http://127.0.0.1/api/hello</code> 你会发现 <code>8080</code> 端口和 <code>9090</code> 端口会以 <code>1-2-1-2-...</code> 的次数交替出现。</p><hr><p>除了 <strong>weight</strong> 外，常见的状态参数还有：</p><table><thead><tr><th style="text-align:left;">配置方式</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">max_fails</td><td style="text-align:left;">允许请求失败次数，默认为 1 。通常和下面的 fail_timeout 连用。</td></tr><tr><td style="text-align:left;">fail_timeout</td><td style="text-align:left;">在经历了 max_fails 次失败后，暂停服务的时长。<small>这段时间内，这台服务器 Nginx 不会请求这台 Server</small></td></tr><tr><td style="text-align:left;">backup</td><td style="text-align:left;">预留的备份机器。<small>它只有在其它非 backup 机器出现故障时或者忙碌的情况下，才会承担负载任务。</small></td></tr><tr><td style="text-align:left;">down</td><td style="text-align:left;">表示当前的 server 不参与负载均衡。</td></tr></tbody></table><p>例如：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>upstream web_server {\n    server 192.168.78.128 weight=1 max_fails=1 fail_timeout=30s;\n    server 192.168.78.200 weight=2 max_fails=1 fail_timeout=30s;\n    server 192.168.78.201 backup;\n    server 192.168.78.210 down;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="负载-ip-hash-负载" tabindex="-1"><a class="header-anchor" href="#负载-ip-hash-负载" aria-hidden="true">#</a> 负载：ip_hash 负载</h2><p>ip_hash 方式的负载均衡，是将每个请求按照访问 IP 的 hash 结果分配，这样就可以使来自同一个 IP 的客户端固定访问一台 Web 服务器，从而就解决了 Session 共享问题。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>upstream xxx {\n    ip_hash;\n    server 127.0.0.1:8080;\n    server 127.0.0.1:9090;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>使用上例配置后，你会发现无论你请求多少次 <code>http://127.0.0.1/api/hello</code> 你所看到的端口始终是 <code>8080</code> 和 <code>9090</code> 中的某一个。</p><h2 id="将客户端浏览器的-ip-传递到后台" tabindex="-1"><a class="header-anchor" href="#将客户端浏览器的-ip-传递到后台" aria-hidden="true">#</a> 将客户端浏览器的 IP 传递到后台</h2><p>对于后台而言，它所面对的『<strong>客户端</strong>』就是 Nginx，后台看不见『<strong>客户端</strong>』浏览器。</p><p>这就意味着，你如果你需要在后台获取客户端浏览器的 IP 地址，你需要明确指出让 Nginx 『<strong>额外地多携带</strong>』一些数据。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>location /api {\n    proxy_pass http://xxx/api;\n    proxy_set_header X-Real-IP $remote_addr;\n\n    # proxy_set_header Cookie $http_cookie;\n    # proxy_set_header Host $http_host;\n    # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在 Spring Boot 的 Controller 中你有 2 种方式来获得这个额外的信息：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">index</span><span class="token punctuation">(</span>\n        <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span>\n        <span class="token annotation punctuation">@RequestHeader</span><span class="token punctuation">(</span><span class="token string">&quot;X-Real-IP&quot;</span><span class="token punctuation">)</span> <span class="token class-name">String</span> realIP2<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">String</span> realIP1 <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token string">&quot;X-Real-IP&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div>',38),t={render:function(n,s){return e}}}}]);