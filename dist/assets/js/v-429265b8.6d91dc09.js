"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[1001],{23341:(e,i,t)=>{t.r(i),t.d(i,{data:()=>o});const o={key:"v-429265b8",path:"/git/302-%E5%9B%BE%E8%A7%A3top10.html",title:"动画图解 Git 的 10 大命令",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"前言",slug:"前言",children:[]},{level:2,title:"合并中 Merging",slug:"合并中-merging",children:[{level:3,title:"--ff：Fast-forward",slug:"ff-fast-forward",children:[]},{level:3,title:"--no-ff：No-fast-foward",slug:"no-ff-no-fast-foward",children:[]}]},{level:2,title:"合并冲突 Merge Conflicts",slug:"合并冲突-merge-conflicts",children:[]},{level:2,title:"变基（Rebasing）",slug:"变基-rebasing",children:[]},{level:2,title:"交互式变基（Interactive Rebase）",slug:"交互式变基-interactive-rebase",children:[]},{level:2,title:"重置（Resetting）",slug:"重置-resetting",children:[]},{level:2,title:"还原（Reverting）",slug:"还原-reverting",children:[]},{level:2,title:"拣选（Cherry-picking）",slug:"拣选-cherry-picking",children:[]},{level:2,title:"取回（Fetching）",slug:"取回-fetching",children:[]},{level:2,title:"拉取（Pulling）",slug:"拉取-pulling",children:[]},{level:2,title:"10. Reflog",slug:"_10-reflog",children:[]}],filePathRelative:"git/302-图解top10.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},14536:(e,i,t)=>{t.r(i),t.d(i,{default:()=>a});const o=(0,t(66252).uE)('<h1 id="动画图解-git-的-10-大命令" tabindex="-1"><a class="header-anchor" href="#动画图解-git-的-10-大命令" aria-hidden="true">#</a> 动画图解 Git 的 10 大命令</h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>尽管 Git 是一款非常强大的工具。</p><p>我发现在使用 Git 时，在头脑里可视化地想象它会非常有用：当我执行一个特定命令时，这些分支会如何交互，又会怎样影响历史记录？为什么当我在 <code>master</code> 上执行硬重启，<code>force push</code> 到原分支以及 <code>rimraf</code> 我们的 <code>.git</code> 文件夹时，我的同事哭了？我觉得创建一些最常用且最有用的 Git 命令的可视化示例会是一个完美的用例！下面我将介绍的很多命令都有可选参数——你可以使用这些参数来改变对应命令的行为。而我的示例只会涵盖命令的默认行为，而不会添加（或添加太多）可选配置！</p><h2 id="合并中-merging" tabindex="-1"><a class="header-anchor" href="#合并中-merging" aria-hidden="true">#</a> 合并中 Merging</h2><p>拥有多个分支是很方便的，以使新变更彼此分离，并确保您不会意外将未经批准或破损的变更推到生产中。但一旦这些修改得到了批准许可，我们就可以将其部署到我们的生产分支中了！将更改从一个分支转移到另一个分支的一种方法是执行 <code>git merge</code>! Git 可以执行两种类型的合并：<code>fast-forward</code> 和 <code>no-fast-forward</code> 现在这可能没有多大意义，所以让我们看一下差异！</p><h3 id="ff-fast-forward" tabindex="-1"><a class="header-anchor" href="#ff-fast-forward" aria-hidden="true">#</a> --ff：Fast-forward</h3><p>在当前分支相比于我们要合并的分支没有额外的提交<small>（commit）</small>时，可以执行 <code>fast-forward</code> 合并。</p><p>Git 很懒，首先会尝试执行最简单的选项：<code>fast-forward</code>！这类合并不会创建新的提交，而是会将我们正在合并的分支上的提交直接合并到当前分支。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-01.gif" alt="git-top-10-01"></p><p>完美！现在，我们 <code>dev</code> 可以在分支上获得对 <code>master</code> 分支所做的所有更改。那么 <code>no-fast-forward</code> 又是什么意思呢？</p><h3 id="no-ff-no-fast-foward" tabindex="-1"><a class="header-anchor" href="#no-ff-no-fast-foward" aria-hidden="true">#</a> --no-ff：No-fast-foward</h3><p>如果你的当前分支相比于你想要合并的分支没有任何提交，那当然很好，但很遗憾现实情况很少如此！</p><p>如果我们在当前分支上提交我们想要合并的分支不具备的改变，那么 git 将会执行 <code>no-fast-forward</code> 合并。</p><p>使用 <code>no-fast-forward</code> 合并时，Git 会在当前活动分支上创建新的 <code>merging commit</code> 。</p><p>这个提交的父提交<small>（parent commit）</small>即指向这个活动分支，也指向我们想要合并的分支！</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-02.gif" alt="git-top-10-02"></p><p>没什么大不了的，完美的合并！</p><p>现在，我们在 <code>dev</code> 分支上所做的所有改变都合并到了 <code>master</code> 分支上。</p><h2 id="合并冲突-merge-conflicts" tabindex="-1"><a class="header-anchor" href="#合并冲突-merge-conflicts" aria-hidden="true">#</a> 合并冲突 Merge Conflicts</h2><p>尽管 Git 能够很好地决定如何合并分支以及如何向文件添加修改，但它并不总是能完全自己做决定。</p><p>当我们想要合并的两个分支的同一文件中的同一行代码上有不同的修改，或者一个分支删除了一个文件而另一个分支修改了这个文件时，Git 就不知道如何取舍了。</p><p>在这样的情况下，Git 会询问你想要保留哪种选择？假设在这两个分支中，我们都编辑了 <code>README.md</code> 的第一行。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-03.png" alt="git-top-10-03"></p><p>如果我们想把 <code>dev</code> 合并到 <code>master</code> ，就会出现一个合并冲突：你想要标题是 <code>Hello!</code> 还是 <code>Hey!</code> ？</p><p>当尝试合并这些分支时，Git 会向你展示冲突出现的位置。</p><p>我们可以手动移除我们不想保留的修改，保存这些修改，再次添加这个已修改的文件，然后提交这些修改。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-04.gif" alt="git-top-10-04"></p><p>完成！尽管合并冲突往往很让人厌烦，但这是合理的：Git 不应该瞎猜我们想要保留哪些修改。</p><h2 id="变基-rebasing" tabindex="-1"><a class="header-anchor" href="#变基-rebasing" aria-hidden="true">#</a> 变基（Rebasing）</h2><p>我们刚看到可通过执行 <code>git merge</code> 将一个分支的修改应用到另一个分支。</p><p>另一种可将一个分支的修改融入到另一个分支的方式是执行 <code>git rebase</code> 。</p><p><code>git rebase</code> 会将当前分支的提交复制到指定的分支之上。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-05.gif" alt="git-top-10-05"></p><p>完美，现在我们在 <code>dev</code> 分支上获取了 <code>master</code> 分支上的所有修改。</p><p>变基与合并 有一个重大的区别：Git 不会尝试确定要保留或不保留哪些文件。我们执行 <code>rebase</code> 的分支总是含有我们想要保留的最新近的修改！这样我们不会遇到任何合并冲突，而且可以保留一个漂亮的、线性的 Git 历史记录。</p><p>上面这个例子展示了在 <code>master</code> 分支上的变基。但是，在更大型的项目中，你通常不需要这样的操作。<code>git rebase</code> 在为复制的提交创建新的 hash 时会修改项目的历史记录。</p><p>如果你在开发一个 <code>feature</code> 分支并且 <code>master</code> 分支已经更新过，那么变基就很好用。你可以在你的分支上获取所有更新，这能防止未来出现合并冲突。</p><h2 id="交互式变基-interactive-rebase" tabindex="-1"><a class="header-anchor" href="#交互式变基-interactive-rebase" aria-hidden="true">#</a> 交互式变基（Interactive Rebase）</h2><p>在为提交执行变基之前，我们可以修改它们！我们可以使用交互式变基来完成这一任务。交互式变基在你当前开发的分支上以及想要修改某些提交时会很有用。</p><p>在我们正在 <code>rebase</code> 的提交上，我们可以执行以下 6 个动作：</p><ul><li><strong>reword</strong>：修改提交信息；</li><li><strong>edit</strong>：修改此提交；</li><li><strong>squash</strong>：将提交融合到前一个提交中；</li><li><strong>fixup</strong>：将提交融合到前一个提交中，不保留该提交的日志消息；</li><li><strong>exec</strong>：在每个提交上运行我们想要 rebase 的命令；</li><li><strong>drop</strong>：移除该提交。</li></ul><p>很棒！这样我们就能完全控制我们的提交了。如果你想要移除一个提交，只需 drop 即可。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-06.gif" alt="git-top-10-06"></p><p>如果你想把多个提交融合到一起以便得到清晰的提交历史，那也没有问题！</p><p>交互式变基能为你在 rebase 时提供大量控制，甚至可以控制当前的活动分支。</p><h2 id="重置-resetting" tabindex="-1"><a class="header-anchor" href="#重置-resetting" aria-hidden="true">#</a> 重置（Resetting）</h2><p>当我们不想要之前提交的修改时，就会用到这个命令。也许这是一个 WIP 提交或者可能是引入了 <code>bug</code> 的提交，这时候就要执行 <code>git reset</code> 。</p><p><code>git reset</code> 能让我们不再使用当前台面上的文件，让我们可以控制 <code>HEAD</code> 应该指向的位置。</p><blockquote><p>git reset 执行的重置操作，也被称为「软重置」。</p></blockquote><p>软重置会将 <code>HEAD</code> 移至指定的提交（或与HEAD 相比的提交的索引），而不会移除该提交之后加入的修改！</p><p>假设我们不想保留添加了一个 <code>style.css</code> 文件的提交 <code>9e78i</code>，而且我们也不想保留添加了一个 <code>index.js</code> 文件的提交 <code>035cc</code> 。但是，我们确实又想要保留新添加的 <code>style.css</code> 和 <code>index.js</code> 文件！这是软重置的一个完美用例。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-07.gif" alt="git-top-10-07"></p><p>输入 <code>git status</code> 后，你会看到我们仍然可以访问在之前的提交上做过的所有修改。这很好，这意味着我们可以修复这些文件的内容，之后再重新提交它们！</p><h2 id="还原-reverting" tabindex="-1"><a class="header-anchor" href="#还原-reverting" aria-hidden="true">#</a> 还原（Reverting）</h2><p>另一种撤销修改的方法是执行 <code>git revert</code> 。通过对特定的提交执行还原操作，我们会创建一个包含已还原修改的新提交。</p><blockquote><p>git revert 执行的重置操作，也被称为「硬重置」。</p></blockquote><p>假设 <code>ec5be</code> 添加了一个 <code>index.js</code> 文件。但之后我们发现其实我们再也不需要由这个提交引入的修改了。那就还原 ec5be 提交吧！</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-08.gif" alt="git-top-10-08"></p><p>完美！提交 <code>9e78i</code> 还原了由提交 <code>ec5be</code> 引入的修改。在撤销特定的提交时，<code>git revert</code> 非常有用，同时也不会修改分支的历史。</p><h2 id="拣选-cherry-picking" tabindex="-1"><a class="header-anchor" href="#拣选-cherry-picking" aria-hidden="true">#</a> 拣选（Cherry-picking）</h2><p>当一个特定分支包含我们的活动分支需要的某个提交时，我们对那个提交执行 <code>cherry-pick</code> ！对一个提交执行 cherry-pick 时，我们会在活动分支上创建一个新的提交，其中包含由拣选出来的提交所引入的修改。</p><p>假设 <code>dev</code>l 分支上的提交 <code>76d12</code> 为 <code>index.js</code> 文件添加了一项修改，而我们希望将其整合到 <code>master</code> 分支中。我们并不想要整个 <code>dev</code> 分支，而只需要这个提交！</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-09.gif" alt="git-top-10-09"></p><p>现在 <code>master</code> 分支包含 <code>76d12</code> 引入的修改了。</p><h2 id="取回-fetching" tabindex="-1"><a class="header-anchor" href="#取回-fetching" aria-hidden="true">#</a> 取回（Fetching）</h2><p>如果你有一个远程 Git 分支，比如在 GitHub 上的分支，当远程分支上包含当前分支没有的提交时，可以使用取回。比如当合并了另一个分支或你的同事推送了一个快速修复时。</p><p>通过在这个远程分支上执行 <code>git fetch</code>，我们就可在本地获取这些修改。这不会以任何方式影响你的本地分支：fetch 只是单纯地下载新的数据而已。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-10.gif" alt="git-top-10-10"></p><p>现在我们可以看到自上次推送以来的所有修改了。这些新数据也已经在本地了，我们可以决定用这些新数据做什么了。</p><h2 id="拉取-pulling" tabindex="-1"><a class="header-anchor" href="#拉取-pulling" aria-hidden="true">#</a> 拉取（Pulling）</h2><p>尽管 git fetch 可用于获取某个分支的远程信息，但我们也可以执行 <code>git pull</code> 。<code>git pull</code> 实际上是两个命令合成了一个：<code>git fetch</code> 和 <code>git merge</code> 。</p><p>当我们从来源拉取修改时，我们首先是像 <code>git fetch</code> 那样取回所有数据，然后最新的修改会自动合并到本地分支中。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-11.gif" alt="git-top-10-11"></p><p>很好，我们现在与远程分支完美同步了，并且也有了所有最新的修改！</p><h2 id="_10-reflog" tabindex="-1"><a class="header-anchor" href="#_10-reflog" aria-hidden="true">#</a> 10. Reflog</h2><p>每个人都会犯错，但犯错其实没啥！有时候你可能感觉你把 git repo 完全搞坏了，让你想完全删了了事。</p><p>git reflog 是一个非常有用的命令，可以展示已经执行过的所有动作的日志。包括合并、重置、还原，基本上包含你对你的分支所做的任何修改。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-12.gif" alt="git-top-10-12"></p><p>如果你犯了错，你可以根据 <code>reflog</code> 提供的信息通过重置 HEAD 来轻松地重做！</p><p>假设我们实际上并不需要合并原有分支。当我们执行 <code>git reflog</code> 命令时，我们可以看到这个 repo 的状态在合并前位于 <code>HEAD@{1}</code>。那我们就执行一次 <code>git reset</code>，将 HEAD 重新指向在 <code>HEAD@{1}</code> 的位置。</p><p><img src="https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-13.gif" alt="git-top-10-13"></p><p>我们可以看到最新的动作已被推送给 reflog 。</p>',83),a={render:function(e,i){return o}}}}]);