"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[4500],{26122:(e,t,o)=>{o.r(t),o.d(t,{data:()=>l});const l={key:"v-38f67fd9",path:"/other/04-redis-%E5%B9%82%E7%AD%89.html",title:"RESTful 接口的幂等性",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[],filePathRelative:"other/04-redis-幂等.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},31018:(e,t,o)=>{o.r(t),o.d(t,{default:()=>p});const l=(0,o(66252).uE)('<h1 id="restful-接口的幂等性" tabindex="-1"><a class="header-anchor" href="#restful-接口的幂等性" aria-hidden="true">#</a> RESTful 接口的幂等性</h1><p>产生『<strong>重复数据或数据不一致</strong>』<small>（假定程序业务代码没问题）</small>，绝大部分就是发生了重复的请求，重复请求是指『<strong>同一个请求因为某些原因被多次提交</strong>』。导致这个情况会有几种场景：</p><ol><li><p>微服务场景，在我们传统应用架构中调用接口，要么成功，要么失败。但是在微服务架构下，会有第三个情况『未知』，也就是超时。如果超时了，微服务框架会进行重试；</p></li><li><p>用户交互的时候多次点击。如：快速点击按钮多次；</p></li><li><p>MQ 消息中间件，消息重复消费；</p></li><li><p>第三方平台的接口<small>（如：支付成功回调接口）</small>，因为异常也会导致多次异步回调；</p></li><li><p>其他中间件/应用服务根据自身的特性，也有可能进行重试。</p></li></ol><p>接口的幂等性实际上就是『<strong>接口可重复调用</strong>』，在调用方多次调用的情况下，接口『<strong>最终得到的结果是一致的</strong>』。</p><blockquote><p>以『增删改查』四大操作来看，『删除』和『查询』操作天然是幂等的，没有<small>（或不在乎）</small>重复提交/重复请求问题。因此，幂等需求通常是用在『新增』和『修改』类型的业务上。</p><p>而『修改』类型的业务通过 SQL 改造和 last_upated_at 字段的结合，也可以实现幂等，而无需下述的 token 和去重表方案。</p><p>因此，幂等性的处理重点集中在『新增』型业务上。</p></blockquote><p><img src="https://hemiao3000.gitee.io/java-note-img/images/other/img/幂等-1.png" alt=""></p><p>上述方案适用绝大部分场景。主要思想：</p><ol><li><p>服务端提供了发送 token 的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取 token，服务器会把 token 保存到 redis 中。<small>（微服务肯定是分布式了，如果单机就适用 jvm 缓存）。</small></p></li><li><p>然后调用业务接口请求时，把 token 携带过去，一般放在请求头部。</p></li><li><p>服务器判断 token 是否存在 redis 中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把 redis 中的 token 删除。</p></li><li><p>如果判断 token 不存在 redis 中，就表示是重复操作，直接返回重复标记给 client，这样就保证了业务代码，不被重复执行。</p></li></ol><blockquote><p>其实，这里的 token 起到的就是全局唯一 ID 的作用。</p></blockquote><p>这里的重点在于：<strong>要先删除 token ，再执行业务代码</strong> 。</p><p>因为『后删除 token』的缺陷太致命：如果进行业务处理成功后，删除 redis 中的 token 失败了，那么 token 仍存在于 Redis 中，这时如果发起了第二次请求，那么因为 token 的存在，会认为该操作未被执行过，这样就导致了有可能会发生重复请求。</p><blockquote><p>当然，『先删除 token』也有缺点，如果先删除 token 成功，而随后执行业务逻辑失败，那么需要再返回信息中告知请求方，在重新获得 token，而不能/无法重复利用之前的 token 。</p></blockquote>',12),p={render:function(e,t){return l}}}}]);