"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[1479],{95903:(s,n,a)=>{a.r(n),a.d(n,{data:()=>e});const e={key:"v-fd67214a",path:"/git/201-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93.html",title:"远程仓库",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"在托管网站上创建远程仓库",slug:"在托管网站上创建远程仓库",children:[]},{level:2,title:"克隆远程仓库至本地",slug:"克隆远程仓库至本地",children:[]},{level:2,title:"推送",slug:"推送",children:[]},{level:2,title:"推送冲突",slug:"推送冲突",children:[]},{level:2,title:"大道理、小细节和套话",slug:"大道理、小细节和套话",children:[]}],filePathRelative:"git/201-远程仓库.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},61797:(s,n,a)=>{a.r(n),a.d(n,{default:()=>l});const e=(0,a(66252).uE)('<h1 id="远程仓库" tabindex="-1"><a class="header-anchor" href="#远程仓库" aria-hidden="true">#</a> 远程仓库</h1><blockquote><p>远程<small>（remote）</small>版本库也叫上游<small>（origin）</small>版本库</p></blockquote><p>通常我们并不常亲自建立远程仓库，而是委托给『第三方』。</p><p>常见的操作是，先在第三方上创建『远程 Git 文档库』，然后复制<small>（Clone）</small>出一个『本地 Git 文档库』。</p><h2 id="在托管网站上创建远程仓库" tabindex="-1"><a class="header-anchor" href="#在托管网站上创建远程仓库" aria-hidden="true">#</a> 在托管网站上创建远程仓库</h2><p>常见的代码托管仓库有：</p><ul><li>国外：github、gitlib</li><li>国内：gitee、Coding</li></ul><p>在托管网站上创建项目后，通常项目目录下是空的，可以通过以下 2 种途径初始化该项目：</p><ul><li><p>创建新版本库</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> clone git@148.70.1.4:HeMiao/reader-html.git\n<span class="token builtin class-name">cd</span> reader-html\n<span class="token function">touch</span> README.md\n<span class="token function">git</span> <span class="token function">add</span> README.md\n<span class="token function">git</span> commit -m <span class="token string">&quot;add README&quot;</span>\n<span class="token function">git</span> push -u origin master\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><p>已存在的文件夹或 Git 仓库</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> <span class="token operator">&lt;</span>existing_folder<span class="token operator">&gt;</span>\n<span class="token function">git</span> init\n<span class="token function">git</span> remote <span class="token function">add</span> origin git@148.70.1.4:HeMiao/reader-html.git\n<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>\n<span class="token function">git</span> commit\n<span class="token function">git</span> push -u origin master\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul><h2 id="克隆远程仓库至本地" tabindex="-1"><a class="header-anchor" href="#克隆远程仓库至本地" aria-hidden="true">#</a> 克隆远程仓库至本地</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>git clone &lt;远程文档库的路径&gt; &lt;本地文档库的文件夹名称&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>更具体的的格式为：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>git clone &lt;http://Web服务器地址/远程文档库路径&gt; &lt;本地文档库名称&gt;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><blockquote><p>例如：git clone https://github.com/&lt;用户名&gt;/&lt;项目名&gt;.git</p></blockquote><p>如果你在托管网站上添加了你本机的 ssh-key，那么还可以使用如下格式：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>git clone Git账号@SSH服务器地址:远程文档库路径 本地文档库路径\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><blockquote><p>例如：git clone git@github.com:&lt;用户名&gt;/&lt;项目名&gt;.git</p></blockquote><p>本地 Git 文档库 和 远程 Git 文档库之间是有『关系』的。这种关系体现在 Git 的配置项的 <strong>origin</strong> 属性上。使用 <strong>git config -l</strong> 可以看到：</p><div class="language-properties ext-properties line-numbers-mode"><pre class="language-properties"><code>...\n<span class="token attr-name">remote.origin.url</span><span class="token punctuation">=</span><span class="token attr-value">远程Git文档库地址</span>\n<span class="token attr-name">remote.origin.fetch</span><span class="token punctuation">=</span><span class="token attr-value">+refs/heads/*:refs/remotes/origin/*</span>\n...\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>在日常工作中，<strong>git clone</strong> 命令一个项目通常只会执行一次。</p></blockquote><h2 id="推送" tabindex="-1"><a class="header-anchor" href="#推送" aria-hidden="true">#</a> 推送</h2><p>当我们完成对本地文档库的修改，可以将这些修改『<strong>推送</strong>』到远程 Git 仓库：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>git push origin [分支名称]\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>git push</strong> 有两种模式：</p><ul><li><p>推送本地『<strong>所有</strong>』分支，</p></li><li><p>推送『<strong>当前</strong>』分支。</p></li><li><p>如多使用第一种模式，配置：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> config --global push.default matching\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>第二种模式，配置：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> config --global push.default simple\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul><p>第二种模式更安全，推荐使用第二种。</p><p>无论哪种传送模式，只要执行 <strong>git push --all</strong> 都是推送所有分支。</p><h2 id="推送冲突" tabindex="-1"><a class="header-anchor" href="#推送冲突" aria-hidden="true">#</a> 推送冲突</h2><p>如果远程分支并非你一个人独有，那么很有可能由于别人的提交，导致远程分支向前演进，从而导致 push 失败。此时需要『<strong>三步合并法</strong>』解决冲突问题。</p><ol><li><p>从远程 Git 文档库取回当前所在分支的最新数据。</p></li><li><p>把远程 Git 文档库的分支合并到本地 Git 的分支。这一步可能会出现冲突。解决冲突，合并代码。</p></li><li><p><code>add-commit-push</code> 三联，提交并推送本地数据至远程 Git 文档库。</p></li></ol><p><strong>git pull</strong> 命令可以完成前两部操作。它等价于：先执行 <strong>git fetch</strong>，再执行 <strong>git rebase origin/master</strong> 。</p><h2 id="大道理、小细节和套话" tabindex="-1"><a class="header-anchor" href="#大道理、小细节和套话" aria-hidden="true">#</a> 大道理、小细节和套话</h2><ol><li><p>xxx 只和 xxx 玩，yyy 只和 yyy 玩：</p><p>当你要推送<small>（push，逻辑上就是上传）</small>本地的 xxx 分支时，你上传的目的地一定是远程的 xxx 分支；</p><p>当你要拉取<small>（push，逻辑上就是下载）</small>远程的 yyy 分支时，你下载的目的地一定是本地的 yyy 分支；</p><p>理论上虽然可以，但是实际上我们并不会让本地的 xxx 分支和远程的 yyy 分支有推拉关系。即，本地 xxx 分支只和远程 xxx 分支『玩』，本地 yyy 分支只和远程的 yyy 分支『玩』。</p></li><li><p>推拉<small>（push/pull）</small>都是在更新：</p><p>推送<small>（push）</small>操作的执行的潜在前提是：你的本地 xxx 分支上的代码一定更『新』<small>（版本更高）</small>，否则，你为什么要上传呢？</p><p>拉取<small>（pull）</small>操作的执行的潜在前提是：你的远程 xxx 分支上的代码一定更『新』<small>（版本更高）</small>，否则，你为什么要下载呢？</p><p><strong>推拉都是在更新，只是『方向』不同</strong>：推送，是用本地 xxx 分支更新远程 xxx 分支；拉取，是用远程 xxx 分支更新本地 xxx 分支。</p></li><li><p>合理使用『简称』少费口舌：</p><p>通过 git push 命令推送本地 xxx 分支代码到远程 xxx 分支，实现远程 xxx 分支的代码的更新，简称：通过推送 xxx 分支来更新远程 xxx 分支。</p><p>通过 git pull 命令拉取远程 yyy 分支代码到本地 yyy 分支，实现本地 yyy 分支的代码的更新，简称：通过拉取 yyy 分支来更新本地 yyy 分支。</p></li><li><p>故意推拉『旧代码』是为了放弃：</p><p>可以推送<small>（上传）</small>旧代码，在此之前，你的远程 xxx 分支的代码更新，版本更高，而你推送<small>（上传）</small>的旧代码会覆盖掉远程的新代码；</p><p>也可以拉取<small>（下载）</small>旧代码，在此之前，你的本地 yyy 分支的代码更新，版本更高，而你拉取<small>（下载）</small>的旧代码会覆盖掉本地新代码；</p><p>通常情况下，你不太可能会用旧代码更新新代码，如果你这么干了，意味着你是想废弃新代码中『新』的那部分内容。</p></li></ol><p>『完』</p>',34),l={render:function(s,n){return e}}}}]);