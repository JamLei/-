"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[8152],{1890:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-a4352300",path:"/jdbc/10-spi.html",title:"JAVA SPI 机制",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"自定义 JAVA SPI 实现演示",slug:"自定义-java-spi-实现演示",children:[]},{level:2,title:"JAVA SPI 优缺点总结",slug:"java-spi-优缺点总结",children:[]}],filePathRelative:"jdbc/10-spi.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},34411:(n,s,a)=>{a.r(s),a.d(s,{default:()=>e});const p=(0,a(66252).uE)('<h1 id="java-spi-机制" tabindex="-1"><a class="header-anchor" href="#java-spi-机制" aria-hidden="true">#</a> JAVA SPI 机制</h1><p>SPI 全称是 Service Provider Interface，是一种将服务接口与服务实现分离以达到解耦、可以提升程序可扩展性的机制。引入服务提供者就是引入了 SPI 接口的实现者，通过本地的注册发现获取到具体的实现类，实现轻松的可插拔。</p><p>『JDBC 加载不同类型数据库的驱动』以及『SLF4J 加载不同提供商的日志实现类』背后都有 SPI 机制在起作用。</p><p>从 JDBC 的使用中，我们就能感受到 Java SPI 的核心功能：支持面向接口编程，动态加载接口的实现类。</p><p>以 JDBC 的使用为例讲解 Java SPI 机制的使用流程：</p><ol><li><p>jdk 本地编提供了一个 <strong>java.sql.Driver</strong> 接口</p></li><li><p>mysql 驱动包提供了 <strong>Driver</strong> 接口的实现类 <strong>com.mysql.jdbc.Driver</strong>。</p></li><li><p>mysql 驱动包的 <strong>META-INF/services</strong> 目录下创建了一个以 <strong>java.sql.Driver</strong> 为文件名的文件，文件内容为：<strong>com.mysql.jdbc.Driver</strong> 。<small>其它数据库厂商所提供的 Java 驱动包也是如此。</small></p></li><li><p>程序中通过 <strong>java.util.ServiceLoder</strong> 动态装载实现模块，扫描 <strong>META-INF/services</strong> 目录下的配置文件找到实现类的全类名，把类加载到 JVM 中。</p></li></ol><p>简单来说：</p><ol><li><p>你先定义一个接口。</p></li><li><p>你在一个特定的位置中创建一个与接口完全限定名同名的文件。</p></li><li><p>别人<small>（也可以就是你自己）</small>实现这个接口。</p></li><li><p>在上面那个文件中写下接口实现类的完全限定名。</p></li><li><p>编写代码，并在代码中执行 <strong>ServiceLoader</strong> 的 <strong>load</strong> 方法。</p></li></ol><h2 id="自定义-java-spi-实现演示" tabindex="-1"><a class="header-anchor" href="#自定义-java-spi-实现演示" aria-hidden="true">#</a> 自定义 JAVA SPI 实现演示</h2><p><strong>需求</strong>：通过 JAVA-SPI 的方式实现日志的打印，打印方式需要支持本地直接打印和远程统一打印</p><ol><li>定义一个 <strong>Log</strong> 接口如下：</li></ol><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * 日志接口\n */</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Log</span> <span class="token punctuation">{</span>\n    <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="2"><li>定义两个具体的实现 <strong>LocalLog</strong> 和 <strong>RemoteLog</strong> 如下：</li></ol><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LocalLog</span> <span class="token keyword">implements</span> <span class="token class-name">Log</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我是本地日志打印&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoteLog</span> <span class="token keyword">implements</span> <span class="token class-name">Log</span> <span class="token punctuation">{</span>\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token doc-comment comment">/**\n         * 这边只是为了演示 SPI 的机制，具体远程打印自行实现\n         */</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我是远程日志打印&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ol start="3"><li>在 classpath 下新建一个 META-INF/services 目录，再在 META-INF/services 目录下边新增一个 com.example.spi.Log 文件，文件内容如下：</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>com.example.spi.LocalLog\ncom.example.spi.RemoteLog\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="4"><li>最后新增一个测试类如下：</li></ol><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Log</span><span class="token punctuation">&gt;</span></span> logs <span class="token operator">=</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Log</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Log</span> s <span class="token operator">:</span> logs<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            s<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>运行结果：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>我是本地日志打印\n我是远程日志打印\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="java-spi-优缺点总结" tabindex="-1"><a class="header-anchor" href="#java-spi-优缺点总结" aria-hidden="true">#</a> JAVA SPI 优缺点总结</h2><h3>优点：</h3><ul><li>使用 Java SPI 机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</li></ul><h3>缺点：</h3><ul><li><p>虽然 ServiceLoader 使用的是延迟加载，但是只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。</p></li><li><p>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。</p></li><li><p>多个并发多线程使用 ServiceLoader 类的实例是不安全的。</p></li></ul>',25),e={render:function(n,s){return p}}}}]);