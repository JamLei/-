"use strict";(self.webpackChunkjava_note_vuepress2=self.webpackChunkjava_note_vuepress2||[]).push([[7274],{51805:(a,s,r)=>{r.r(s),r.d(s,{data:()=>n});const n={key:"v-1f3cbca4",path:"/java/00-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.html",title:"为什么要配环境变量",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"环境变量",slug:"环境变量",children:[]},{level:2,title:"PATH 环境变量",slug:"path-环境变量",children:[]},{level:2,title:"Java 环境变量",slug:"java-环境变量",children:[]},{level:2,title:"JAVA_HOME 环境变量",slug:"java-home-环境变量",children:[]},{level:2,title:"JAVA_HOME 的一个副作用",slug:"java-home-的一个副作用",children:[]},{level:2,title:"一个小技巧",slug:"一个小技巧",children:[]}],filePathRelative:"java/00-环境变量.md",git:{updatedTime:1629711344e3,contributors:[{name:"hemiao",email:"hemiao3000@126.com",commits:1}]}}},47078:(a,s,r)=>{r.r(s),r.d(s,{default:()=>t});const n=(0,r(66252).uE)('<h1 id="为什么要配环境变量" tabindex="-1"><a class="header-anchor" href="#为什么要配环境变量" aria-hidden="true">#</a> 为什么要配环境变量</h1><h2 id="环境变量" tabindex="-1"><a class="header-anchor" href="#环境变量" aria-hidden="true">#</a> 环境变量</h2><p>环境变量顾名思义，就是指在系统<small>（Window / Linux）</small>环境中存在着的变量。</p><p>逻辑上，『<strong>环境变量</strong>』类似于编程领域中的全局变量的概念，只不过，这个『<strong>全局</strong>』是一个更大的全局，是操作系统层面的全局。</p><p>理论上，<small>（不考虑访问权限问题）</small>，任何一个程序/进程，如果有需要，都能看得到、访问到这些“全局变量”。</p><p>系统中有一些自带的、默认存在的环境变量，通常情况下『<strong>不要改变这些系统自带的环境变量的值</strong>』，特别是不要删除<small>（不要删除、不要删除）</small>它们的原值。</p><p>如果有需要，你也可以为你的系统<strong>添加新的环境变量</strong>。</p><h2 id="path-环境变量" tabindex="-1"><a class="header-anchor" href="#path-环境变量" aria-hidden="true">#</a> PATH 环境变量</h2><p><strong>PATH</strong> 是操作系统中的环境变量之一，它是系统自带的环境变量。</p><p>在使用操作系统过程中，你会在控制台/终端输入命令。<strong>每一个命令的背后都有一个与之对应的可执行程序</strong>，在 Windows 上就是 <strong>.exe</strong> 和 <strong>.bat</strong> 这样的可执行程序。</p><blockquote><p><small>上面这句话中的『每个』和『都有』，不是 100% 正确，但是绝大多数情况下都是如此。这就是『内部命令』和『外部命令』的区别，这里不扩展讲解。</small></p></blockquote><p>那么，一个很显而易见的问题来了：操作系统如何知道这些命令『背后』的执行程序在哪？它怎么知道去哪里找这些可执行程序？</p><p>操作系统靠 <strong>PATH</strong> 环境变量。<strong>PATH</strong> 环境变量的值，是多个目录的路径。<small>在 Win 10 中，这些路径每一个都是独行展示；在 Win 7 中这些路径名是以 <code>;</code> 作为分隔符来连在一起，写作一行。</small></p><p>当『你』输入了一个命令，要求操作系统去执行某项操作时，操作系统会去 <strong>PATH</strong> 的这些目录下挨个查找是否有与命令同名的可执行程序。有，则执行；没有，则会报错。</p><h2 id="java-环境变量" tabindex="-1"><a class="header-anchor" href="#java-环境变量" aria-hidden="true">#</a> Java 环境变量</h2><p>当你要进行 Java 编程，或者是运行 Java 程序时，你会直接或间接使用到 <strong>javac</strong> 和 <strong>java</strong> 命令。</p><p>当你安装了 JDK 之后<small>（假定你没有自定义安装路径，使用的是默认路径）</small>，你所安装的 JDK 的路径 <strong>C:\\Program Files\\Java\\jdk1.8.0_201</strong> 下的 <strong>bin</strong> 目录下会存在 <strong>javac.exe</strong> 和 <strong>java.exe</strong> 这样一批可执行程序。</p><p>但是问题是：当你输入 <strong>javac</strong> 或 <strong>java</strong> 命令时，Windows 不知道到这个 <strong>bin</strong> 目录下找 <strong>.exe</strong> 可执行程序！</p><p>因此，在安装完 JDK 之后，你需要将这个装有 <strong>javac</strong> 和 <strong>java</strong><small>（还有其他的命令的对应的执行程序）</small>的 <strong>bin</strong> 目录『告诉』给 Windows 。以便于，让它知道要到这个目录下找可执行文件。</p><p>因此，我们需要将 <strong>C:\\Program Files\\Java\\jdk1.8.0_201\\bin</strong> 目录添加<small>（添加、添加，不要删除 PATH 的原值）</small>到环境变量 <strong>PATH</strong> 中。</p><h2 id="java-home-环境变量" tabindex="-1"><a class="header-anchor" href="#java-home-环境变量" aria-hidden="true">#</a> JAVA_HOME 环境变量</h2><p>有一些依赖于 Java 开发/运行环境的软件<small>（例如 Tomcat）</small>在运行时有一个前提条件：它会要求系统的环境变量中存在一个名为 <strong>JAVA_HOME</strong> 的环境变量，<small>先估且不谈这个环境变量的值是什么，</small><strong>如果这个环境变量如果不存在，那么这些软件就会直接运行失败</strong>。</p><p>这个『前提条件』是这些依赖于 Java 开发/运行环境的软件自身硬编码定死的，『你』作为这些软件的使用者无法更改这一点，只能遵守它，满足这个前提条件。</p><p>因此，为了能正常使用这些依赖于 Java 开发/运行环境的软件，我们必须确保操作系统的环境变量中存在一个名为 <strong>JAVA_HOME</strong> 的环境变量。<strong>如果没有，必须添加它</strong> 。</p><p><strong>JAVA_HOME</strong> 这个环境变量的值，应该是你的 JDK 的安装路径。例如：<code>C:\\Program Files\\Java\\jdk1.8.0_201</code> 。注意，这不是上面说的那个 bin 目录，而是 bin 目录的上一级目录。</p><p>本质上，就是因为这些软件在运行中要使用这个目录下的东西。所以，它们要求你通过一个名为 <strong>JAVA_HOME</strong> 环境变量来告知它们这个目录在哪。</p><h2 id="java-home-的一个副作用" tabindex="-1"><a class="header-anchor" href="#java-home-的一个副作用" aria-hidden="true">#</a> JAVA_HOME 的一个副作用</h2><p>本来，<strong>JAVA_HOME</strong> 环境变量和 <strong>PATH</strong> 环境变量是没有直接关系的。</p><p>但是，“碰巧”的是我们添加到 <strong>PATH</strong> 中的指明 .exe 文件所在地的 <strong>C:\\Program Files\\Java\\jdk1.8.0_201</strong><em>\\bin</em> 中的前一段不正好就是 <strong>JAVA_HOME</strong> 吗？！</p><p>因此，我们可以在 <strong>PATH</strong> 中利用 <strong>JAVA_HOME</strong>。反正，你用或者不用，<strong>JAVA_HOME</strong> 都是存在着的。</p><p>因此，我们在 <strong>PATH</strong> 中添加的内容，就可以『简化』成：<strong>%JAVA_HOME%/bin</strong> 。</p><h2 id="一个小技巧" tabindex="-1"><a class="header-anchor" href="#一个小技巧" aria-hidden="true">#</a> 一个小技巧</h2><p>Windows 操作系统有一个 <strong>where</strong> 命令，Linux 操作系统有一个 <strong>which</strong> 命令，它们都能告诉你：你要执行的命令『背后』的可执行程序在哪里。</p><p>以 Windows 为例：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>where javac\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>如果 where 命令有正常的输出结果，那么就意味着操作系统能找得到命令『背后』的那个可执行程序，那么该命令自然可以正常使用。</p>',36),t={render:function(a,s){return n}}}}]);